/* File generated with Shader Minifier 1.1.3.r.1
 * http://www.ctrl-alt-test.fr
 */
#ifndef SHADER_CODE_INTRO_H_
#define SHADER_CODE_INTRO_H_

const char* const water_vert =
 "varying vec3 cameraPosition,viewDirection;"
 "varying mat4 pmat,mview,mviewproj;"
 "void main()"
 "{"
   "gl_Position=gl_Vertex;"
   "vec4 v=gl_Vertex;"
   "v=gl_ProjectionMatrixInverse*v;"
   "v/=v.w;"
   "v=gl_ModelViewMatrixInverse*v;"
   "vec4 nearPlanePosition=v/v.w;"
   "mview=gl_ModelViewMatrix;"
   "mviewproj=gl_ModelViewProjectionMatrix;"
   "pmat=gl_ProjectionMatrix;"
   "cameraPosition=(gl_ModelViewMatrixInverse*vec4(0.,0.,0.,1.)).xyz;"
   "viewDirection=normalize(nearPlanePosition-cameraPosition).xyz;"
 "}";

const char* const water_frag =
 "varying vec2 uv;"
 "uniform float time;"
 "uniform sampler2D iChannel0,iChannel1,iChannel2,mask;"
 "varying mat4 mview;"
 "varying float znear,zfar,nearPlane,farPlane;"
 "varying mat4 pmat;"
 "uniform vec3 sky1,sky2,lig,cube,objectPos;"
 "uniform float objectMix;"
 "varying vec3 cameraPosition;"
 "varying float nearPlanePosition;"
 "varying vec3 viewDirection;"
 "varying mat4 mviewproj;\n"
 "#define pi2 6.28318530718\n"
 "const float precis=.015;"
 "uniform vec2 g_resolution;"
 "const int NUM_STEPS=8;"
 "const float PI=3.1415,EPSILON=.001;"
 "float EPSILON_NRM=.1/g_resolution.x;"
 "const int ITER_GEOMETRY=3,ITER_FRAGMENT=5;"
 "const float SEA_HEIGHT=.6,SEA_CHOPPY=4.,SEA_SPEED=.8,SEA_FREQ=.16;"
 "const vec3 COL_SEA_BASE=vec3(.05,.1,.1),SEA_WATER_COLOR=vec3(.1,.6,.8);"
 "float SEA_TIME=time*SEA_SPEED;"
 "mat2 octave_m=mat2(1.6,1.2,-1.2,1.6);"
 "const float MAT_SEA=1.,MAT_OBJ=2.;"
 "mat3 fromEuler(vec3 ang)"
 "{"
   "vec2 a1=vec2(sin(ang.x),cos(ang.x)),a2=vec2(sin(ang.y),cos(ang.y)),a3=vec2(sin(ang.z),cos(ang.z));"
   "mat3 m;"
   "m[0]=vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);"
   "m[1]=vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);"
   "m[2]=vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);"
   "return m;"
 "}"
 "float hash(vec2 p)"
 "{"
   "float h=dot(p,vec2(127.1,311.7));"
   "return fract(sin(h)*43758.5);"
 "}"
 "float noise(in vec2 p)"
 "{"
   "vec2 i=floor(p),f=fract(p),u=f*f*(3.-2.*f);"
   "return-1.+2.*mix(mix(hash(i+vec2(0.,0.)),hash(i+vec2(1.,0.)),u.x),mix(hash(i+vec2(0.,1.)),hash(i+vec2(1.,1.)),u.x),u.y);"
 "}"
 "float diffuse(vec3 n,vec3 l,float p)"
 "{"
   "return pow(dot(n,l)*.4+.6,p);"
 "}"
 "float specular(vec3 n,vec3 l,vec3 e,float s)"
 "{"
   "float nrm=(s+8.)/25.132;"
   "return pow(max(dot(reflect(e,n),l),0.),s)*nrm;"
 "}"
 "vec3 background(vec3 p,vec3 d)"
 "{"
   "vec3 color=mix(sky1,sky2,d.y*.5+.5);"
   "return 2.5*color*(noise(d)+.3*pow(noise(d*4.),2.));"
 "}"
 "vec3 getSkyColor(vec3 e)"
 "{"
   "e.y=max(e.y,0.);"
   "vec3 ret;"
   "ret.x=pow(1.-e.y,2.);"
   "ret.y=1.-e.y;"
   "ret.z=.6+(1.-e.y)*.4;"
   "vec3 light=normalize(vec3(0.,1.,.8));"
   "ret=background(e,light)*5.;"
   "return ret;"
 "}"
 "float sea_octave(vec2 uv,float choppy)"
 "{"
   "uv+=noise(uv);"
   "vec2 wv=1.-abs(sin(uv)),swv=abs(cos(uv));"
   "wv=mix(wv,swv,wv);"
   "return pow(1.-pow(wv.x*wv.y,.65),choppy);"
 "}"
 "float sdBox(vec3 p,vec3 b)"
 "{"
   "vec3 d=abs(p)-b;"
   "return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));"
 "}"
 "float map_water(vec3 p)"
 "{"
   "float freq=SEA_FREQ,amp=SEA_HEIGHT,choppy=SEA_CHOPPY;"
   "vec2 uv=p.xz;"
   "uv.x*=.75;"
   "float d,h=0.;"
   "for(int i=0;i<ITER_GEOMETRY;i++)"
     "{"
       "d=sea_octave((uv+SEA_TIME)*freq,choppy);"
       "d+=sea_octave((uv-SEA_TIME)*freq,choppy);"
       "h+=d*amp;"
       "uv*=octave_m;"
       "freq*=1.9;"
       "amp*=.22;"
       "choppy=mix(choppy,1.,.2);"
     "}"
   "return p.y-h;"
 "}"
 "float map_water_detailed(vec3 p)"
 "{"
   "float freq=SEA_FREQ,amp=SEA_HEIGHT,choppy=SEA_CHOPPY;"
   "vec2 uv=p.xz;"
   "uv.x*=.75;"
   "float d,h=0.;"
   "for(int i=0;i<ITER_FRAGMENT;i++)"
     "{"
       "d=sea_octave((uv+SEA_TIME)*freq,choppy);"
       "d+=sea_octave((uv-SEA_TIME)*freq,choppy);"
       "h+=d*amp;"
       "uv*=octave_m;"
       "freq*=1.9;"
       "amp*=.22;"
       "choppy=mix(choppy,1.,.2);"
     "}"
   "return p.y-h;"
 "}"
 "vec3 getSeaColor(vec3 p,vec3 n,vec3 l,vec3 eye,vec3 dist,vec3 bg)"
 "{"
   "vec3 light=normalize(vec3(0.,1.,.8));"
   "float fresnel=1.-max(dot(n,-eye),0.);"
   "fresnel=pow(fresnel,3.)*.65;"
   "vec3 reflected=getSkyColor(reflect(eye,n)),refracted=COL_SEA_BASE+diffuse(n,l,80.)*SEA_WATER_COLOR*.12,color=mix(refracted,reflected,fresnel);"
   "float atten=max(1.-dot(dist,dist)*.001,0.);"
   "color+=SEA_WATER_COLOR*(p.y-SEA_HEIGHT)*.18*atten;"
   "color+=vec3(specular(n,l,eye,60.));"
   "return color;"
 "}"
 "vec3 getNormal(vec3 p,float eps,float mat)"
 "{"
   "vec3 n;"
   "if(mat==MAT_SEA)"
     "{"
       "n.y=map_water_detailed(p);"
       "n.x=map_water_detailed(vec3(p.x+eps,p.y,p.z))-n.y;"
       "n.z=map_water_detailed(vec3(p.x,p.y,p.z+eps))-n.y;"
       "n.y=eps;"
     "}"
   "else"
     ";"
   "return normalize(n);"
 "}"
 "vec2 march(vec3 ori,vec3 dir,out vec3 p)"
 "{"
   "vec2 res=vec2(1000.,-1.);"
   "float tm=0.,tx=1000.,hx=map_water(ori+dir*tx);"
   "if(hx>0.)"
     "return vec2(tx,0);"
   "float hm=map_water(ori+dir*tm),tmid=0.;"
   "for(int i=0;i<NUM_STEPS;i++)"
     "{"
       "tmid=mix(tm,tx,hm/(hm-hx));"
       "p=ori+dir*tmid;"
       "float hmid=map_water(p);"
       "if(hmid<0.)"
         "{"
           "tx=tmid;"
           "hx=hmid;"
         "}"
       "else"
         "{"
           "tm=tmid;"
           "hm=hmid;"
         "}"
     "}"
   "res.x=tmid;"
   "float maxd=500.,t=0.,d=0.,m=1.,dis=100000.;"
   "const float precis=.015;"
   "for(int steps=0;steps<150;steps++)"
     "{"
       "if(abs(dis)<precis||t>maxd)"
         "continue;"
       "t+=dis;"
       "dis=sdBox(ori+dir*t,vec3(100.1));"
     "}"
   "dis=min(tmid,dis);"
   "p=ori+dir*dis;"
   "return vec2(dis,dis==tmid?MAT_SEA:MAT_OBJ);"
 "}"
 "void main()"
 "{"
   "vec2 uv=gl_FragCoord.xy/g_resolution.xy;"
   "uv=uv*2.-1.;"
   "uv.x*=g_resolution.x/g_resolution.y;"
   "float time=time*.3;"
   "vec3 ang=vec3(sin(time*3.)*.1,sin(time)*.2+.3,time),ori=cameraPosition,dir=normalize(vec3(uv.xy,-2.));"
   "dir.z+=length(uv)*.15;"
   "dir=normalize(viewDirection);"
   "vec3 p;"
   "vec2 obj=march(ori,dir,p);"
   "vec3 dist=p-ori,n=getNormal(p,dot(dist,dist)*EPSILON_NRM,obj.y),light=normalize(vec3(0.,1.,.8)),bg=background(light,dir),color=mix(getSkyColor(dir),getSeaColor(p,n,light,dir,dist,bg),pow(smoothstep(0.,-.05,dir.y),.3));"
   "gl_FragColor=vec4(pow(color,vec3(.75)),1.);"
 "}";

const char* const txt_vert =
 "#version 330\n"
 "uniform mat4 mvm,pm;"
 "uniform mat3 nm;"
 "uniform vec3 offset;"
 "uniform float txtAmount,time;"
 "layout(location=0)in vec4 position;"
 "layout(location=1)in vec3 normal;"
 "layout(location=2)in float distance;"
 "out vec3 viewspacePosition3,viewspaceNormal;"
 "out vec4 viewspacePosition4;"
 "mat3 rotz(in float a)"
 "{"
   "float ca=cos(a),sa=sin(a);"
   "return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.);"
 "}"
 "mat3 rotx(in float a)"
 "{"
   "float ca=cos(a),sa=sin(a);"
   "return mat3(1.,0.,0.,0.,ca,-sa,0.,sa,ca);"
 "}"
 "mat3 roty(in float a)"
 "{"
   "float ca=cos(a),sa=sin(a);"
   "return mat3(ca,0.,sa,0.,1.,0.,-sa,0.,ca);"
 "}"
 "void main()"
 "{"
   "vec4 pos=position;"
   "pos.xyz*=rotx(.6-txtAmount);"
   "pos.xyz*=rotz(1.-txtAmount);"
   "pos.xyz*=roty(1.-txtAmount);"
   "float rv=abs(-1.+mod(time*.5,2.))-.5;"
   "pos.xyz*=rotz(rv);"
   "pos.xyz*=txtAmount;"
   "pos.xyz+=offset;"
   "viewspacePosition4=pos;"
   "viewspacePosition3=viewspacePosition4.xyz;"
   "viewspaceNormal=normalize(vec3(normal));"
   "gl_Position=pm*pos;"
 "}";

const char* const txt_frag =
 "#version 330\n"
 "uniform sampler2D t;"
 "uniform vec3 lig;"
 "in vec3 viewspacePosition3,viewspaceNormal;"
 "in vec4 viewspacePosition4;"
 "vec4 lambertian(vec4 ambientColor,vec4 diffuseColor,vec4 specularColor,float diffuseFactor,float specularFactor,float specularPow,vec3 pos,vec3 eyePos,vec3 lightPos,vec3 normal)"
 "{"
   "vec4 color=ambientColor;"
   "vec3 N=normalize(normal),L=normalize(lightPos-pos);"
   "float lambertTerm=dot(N,L);"
   "if(lambertTerm>0.)"
     "{"
       "color+=diffuseColor*lambertTerm*diffuseFactor;"
       "vec3 E=normalize(eyePos-pos),R=reflect(-L,N);"
       "float specularTerm=pow(max(dot(R,E),0.),specularPow);"
       "color+=specularColor*specularTerm*specularFactor;"
     "}"
   "return color;"
 "}"
 "void main()"
 "{"
   "vec3 lt=vec3(3.,0.,90.);"
   "gl_FragColor=lambertian(vec4(.2,.2,.2,1.),vec4(.1,.1,.1,1.),vec4(1.,1.,1.,1.),.5,1.3,8.,viewspacePosition3,vec3(0),vec4(lt,1.).xyz,viewspaceNormal);"
 "}";

const char* const tv_vs_glsl =
 "varying vec2 pos;"
 "void main()"
 "{"
   "pos=-((gl_Vertex-1.)*.5);"
   "gl_Position=gl_Vertex;"
 "}";

const char* const tv_vert =
 "varying vec2 pos;"
 "void main()"
 "{"
   "pos=(gl_Vertex-1.)*.5;"
   "gl_Position=gl_Vertex;"
 "}";

const char* const tv_fs_glsl =
 "#define ENABLED 1\n"
 "uniform sampler2D input0;"
 "uniform vec2 viewportSize;"
 "varying vec2 pos;"
 "uniform float fTime,fFlashAmount,fReflectionSize,fDeformValue,fScreenSize1,fScreenSize2,fScreenSize3;"
 "const float PI=3.14159;"
 "float lens=PI/fDeformValue,screenWidth=viewportSize.x,screenHeight=viewportSize.y;"
 "vec2 zoom(in vec2 p,in float radius)"
 "{"
   "float zoom=1.5-(radius*cos(p.x*PI/lens)+radius*cos(p.y*PI/lens));"
   "return vec2(p.x*zoom-.5,p.y*zoom-.5);"
 "}"
 "vec3 deform(in sampler2D tex,in vec2 p)"
 "{"
   "return p.x<-1.||p.x>0.||p.y<-1.||p.y>0.?vec3(0.,0.,0.):texture2D(tex,p).xyz;"
 "}"
 "float rand(in vec2 p)"
 "{"
   "return fract(sin(dot(p.xy,vec2(12.9898,78.233)))*43758.5);"
 "}"
 "void main()"
 "{"
   "vec2 p=vec2(0.,0.);"
   "p.x=1.-pos.x*2.;"
   "p.y=1.-pos.y*2.;"
   "vec2 q=pos,z=zoom(p,fScreenSize1),z1=zoom(p,fScreenSize2),z2=zoom(p,fScreenSize3);"
   "float g=(2.-cos(PI/lens/2.+z.x*PI/lens)-cos(PI/lens/2.+z.y*PI/lens))*32.,rnd1=rand(vec2(p.x+fTime,p.y-fTime)),rnd2=rand(vec2(p.x-fTime,p.y+fTime)),d=rnd1*2./float(screenWidth);"
   "vec3 source=deform(input0,z),glass1=deform(input0,z1),glass2=deform(input0,z2);"
   "float v=fReflectionSize*g;"
   "vec3 noise;"
   "noise.x=deform(input0,vec2(z.x-d-v,z.y-d)).x;"
   "noise.y=deform(input0,vec2(z.x,z.y)).y;"
   "noise.z=deform(input0,vec2(z.x-d+v,z.y-d)).z;"
   "vec3 color=source+glass1*glass1+glass2*.1+noise*.15;"
   "color+=fFlashAmount;"
   "color-=(vec3(rnd1,rnd1,rnd1)-vec3(rnd2,rnd2,rnd2))*.125;"
   "color*=.75+.25*sin(z.x*float(screenWidth)*10.2);"
   "color*=.9+.1*cos(z.y*float(screenHeight)*10.2)*sin(.5+z.x*float(screenWidth)*10.2);"
   "color*=.975+.025*sin(fTime*77.7*cos(fTime*191.1));"
   "\n#if ENABLED==1\n"
   "gl_FragColor=vec4(color,1.);"
   "\n#else\n"
   "gl_FragColor=texture2D(input0,vec2(1.,1.)-pos);"
   "\n#endif\n"
   "return;"
 "}";

const char* const tv_frag =
 "varying vec2 pos;"
 "uniform sampler2D input0;"
 "uniform float fTime,pScanline,pSlowscan,pColorshift_x,pColorshift_y,pVignettessoftness,pVignettescale,pAddGrain,grain_opacity,g_saturation,pFrequency,pDistort,timer,speed,Distort,Scale,stripes_count,Opacity,bars_count,opacity_moire,moire_scale,tv_lines,tv_lines_speed,tv_lines_opacity,tv_tube_vignette_scale,tv_dots,tv_dots_blend,bw_soft,bw_threshold,rgb_offset_amount;"
 "uniform bool vhs_bars,vhs_stripes,moire,add_vignette,tv_tube_vignette,tv_tube_lines,tube_moire,rgb_offset,b_w,vcr_distortion,slow_scan,scanline_scan,tube_distortion,scanline_distort;"
 "uniform vec3 monochrome;"
 "uniform vec2 viewportSize;"
 "float rand(vec2 co)"
 "{"
   "return fract(sin(dot(co.xy,vec2(12.9898,78.233)))*43758.5);"
 "}"
 "vec3 noise(vec2 uv)"
 "{"
   "vec2 c=viewportSize.x*vec2(1.,viewportSize.y/viewportSize.x);"
   "vec3 col=vec3(0.);"
   "uv.y=uv.y;"
   "float r=rand(vec2((2.+fTime)*floor(uv.x*c.x)/c.x,(2.+fTime)*floor(uv.y*c.y)/c.y)),g=rand(vec2((5.+fTime)*floor(uv.x*c.x)/c.x,(5.+fTime)*floor(uv.y*c.y)/c.y)),b=rand(vec2((9.+fTime)*floor(uv.x*c.x)/c.x,(9.+fTime)*floor(uv.y*c.y)/c.y));"
   "col=vec3(r,g,b);"
   "return col;"
 "}"
 "float overlay(float s,float d)"
 "{"
   "return d<.5?2.*s*d:1.-2.*(1.-s)*(1.-d);"
 "}"
 "vec3 overlay(vec3 s,vec3 d)"
 "{"
   "vec3 c;"
   "c.x=overlay(s.x,d.x);"
   "c.y=overlay(s.y,d.y);"
   "c.z=overlay(s.z,d.z);"
   "return c;"
 "}"
 "float rand(float c)"
 "{"
   "return rand(vec2(c,1.));"
 "}"
 "float ramp(float y,float start,float end)"
 "{"
   "float inside=step(start,y)-step(end,y),fact=(y-start)/(end-start)*inside;"
   "return(1.-fact)*inside;"
 "}"
 "float scanline(vec2 uv)"
 "{"
   "return sin(viewportSize.y*uv.y*pScanline-fTime*10.);"
 "}"
 "float slowscan(vec2 uv)"
 "{"
   "return sin(viewportSize.y*uv.y*pSlowscan+fTime*6.);"
 "}"
 "vec2 crt(vec2 coord,float bend)"
 "{"
   "coord=(coord-.5)*2./Scale;"
   "coord*=.5;"
   "coord.x*=1.+pow(abs(coord.y)/bend*Distort,2.);"
   "coord.y*=1.+pow(abs(coord.x)/bend*Distort,2.);"
   "coord=coord+.5;"
   "return coord;"
 "}"
 "vec2 scandistort(vec2 uv)"
 "{"
   "float scan1=clamp(cos(uv.y*speed+fTime*timer),0.,1.),scan2=clamp(cos(uv.y*speed+fTime*timer+4.)*10.,0.,1.),amount=scan1*scan2*uv.x;"
   "uv.x-=pDistort*mix(texture2D(input0,vec2(uv.x,amount)).x*amount,amount,.9);"
   "return uv;"
 "}"
 "float onOff(float a,float b,float c)"
 "{"
   "return step(c,sin(fTime+a*cos(fTime*b)));"
 "}"
 "vec3 getVideo(vec2 uv)"
 "{"
   "vec2 look=uv;"
   "float window=1./(1.+20.*(look.y-mod(fTime/4.,1.))*(look.y-mod(fTime/4.,1.)));"
   "look.x=look.x+sin(look.y*10.+fTime)/50.*onOff(4.,4.,.3)*(1.+cos(fTime*80.))*window;"
   "float vShift=.4*onOff(2.,3.,.9)*(sin(fTime)*sin(fTime*20.)+(.5+.1*sin(fTime*200.)*cos(fTime)));"
   "look.y=mod(look.y+vShift,1.);"
   "vec3 video=vec3(texture2D(input0,look));"
   "return video;"
 "}"
 "vec2 screenDistort(vec2 uv)"
 "{"
   "uv-=vec2(.5,.5);"
   "uv=uv*1.2*(1./1.2+2.*uv.x*uv.x*uv.y*uv.y);"
   "uv+=vec2(.5,.5);"
   "return uv;"
 "}"
 "float vignette(vec2 uv)"
 "{"
   "uv=(uv-.5)*.98;"
   "return clamp(pow(cos(uv.x*3.1415),pVignettescale)*pow(cos(uv.y*3.1415),pVignettescale)*pVignettessoftness,0.,1.);"
 "}"
 "float stripes(vec2 uv)"
 "{"
   "float noi=rand(uv*vec2(.5,1.)+vec2(1.,3.))*Opacity;"
   "return ramp(mod(uv.y*stripes_count+fTime/2.+sin(fTime+sin(fTime*2.)),1.),.5,.6)*noi;"
 "}"
 "vec4 rbg_split(vec2 uv)"
 "{"
   "vec2 texel=1./viewportSize.xy,coords=(uv-.5)*2.;"
   "float coordDot=dot(coords,coords);"
   "vec2 precompute=rgb_offset_amount*coordDot*coords,uvR=uv-texel.xy*precompute,uvB=uv+texel.xy*precompute;"
   "vec4 color;"
   "color.x=texture2D(input0,uvR).x;"
   "color.y=texture2D(input0,uv).y;"
   "color.z=texture2D(input0,uvB).z;"
   "color.w=1.;"
   "return color;"
 "}"
 "void main()"
 "{"
   "vec2 uv=pos,uv2=pos*2.-1.,uv3=pos*2.-1.;"
   "vec3 grain=noise(uv),grau=vec3(.5);"
   "vec2 sd_uv=uv;"
   "if(scanline_distort)"
     "sd_uv=scandistort(uv);"
   "vec2 crt_uv=sd_uv;"
   "if(tube_distortion)"
     "crt_uv=crt(sd_uv,2.);"
   "vec4 color;"
   "if(!rgb_offset)"
     "{"
       "color=texture2D(input0,crt_uv).xyzw;"
     "}"
   "else"
     "{"
       "color=rbg_split(crt_uv).xyzw;"
     "}"
   "vec4 scanline_color=color,slowscan_color=color;"
   "if(vcr_distortion)"
     "{"
       "color=vec4(getVideo(crt_uv),1.);"
     "}"
   "if(scanline_scan)"
     "scanline_color=vec4(scanline(crt_uv));"
   "if(slow_scan)"
     "slowscan_color=vec4(slowscan(crt_uv));"
   "if(tube_moire)"
     "{"
       "color*=1.+tv_dots_blend*.2*sin(crt_uv.x*float(viewportSize.x*5.*tv_dots));"
       "color*=1.+tv_dots_blend*.2*cos(crt_uv.y*float(viewportSize.y))*sin(.5+crt_uv.x*float(viewportSize.x));"
     "}"
   "if(vhs_stripes)"
     "color*=1.+stripes(crt_uv);"
   "if(vhs_bars)"
     "color*=(12.+mod(crt_uv.y*bars_count+fTime,1.))/13.;"
   "if(moire)"
     "color*=.45+rand(crt_uv*.01*moire_scale)*opacity_moire;"
   "if(pAddGrain)"
     "{"
       "grain=mix(grau,grain,grain_opacity*.1);"
       "vec3 bw_grain=vec3(grain.x);"
       "grain=mix(bw_grain,grain,g_saturation);"
       "color=vec4(overlay(grain,vec3(color)),1.);"
     "}"
   "if(add_vignette)"
     "color*=vignette(uv);"
   "if(tv_tube_vignette)"
     "color*=1.-pow(length(uv2*uv2*uv2*uv2),6./tv_tube_vignette_scale);"
   "if(tv_tube_lines)"
     "{"
       "crt_uv.y+=fTime*tv_lines_speed;"
       "crt_uv.y*=viewportSize.y/viewportSize.y*tv_lines;"
       "color.x*=(.55+abs(.5-mod(crt_uv.y,.021)/.021)*tv_lines_opacity)*1.2;"
       "color.y*=(.55+abs(.5-mod(crt_uv.y+.007,.021)/.021)*tv_lines_opacity)*1.2;"
       "color.z*=(.55+abs(.5-mod(crt_uv.y+.014,.021)/.021)*tv_lines_opacity)*1.2;"
     "}"
   "gl_FragColor=mix(color,mix(scanline_color,slowscan_color,.5),.05);"
 "}";

const char* const tunnel_vert =
 "varying vec3 cameraPosition,viewDirection;"
 "varying mat4 pmat,mview,mviewproj;"
 "void main()"
 "{"
   "gl_Position=gl_Vertex;"
   "vec4 v=gl_Vertex;"
   "v=gl_ProjectionMatrixInverse*v;"
   "v/=v.w;"
   "v=gl_ModelViewMatrixInverse*v;"
   "vec4 nearPlanePosition=v/v.w;"
   "mview=gl_ModelViewMatrix;"
   "mviewproj=gl_ModelViewProjectionMatrix;"
   "pmat=gl_ProjectionMatrix;"
   "cameraPosition=(gl_ModelViewMatrixInverse*vec4(0.,0.,0.,1.)).xyz;"
   "viewDirection=normalize(nearPlanePosition-cameraPosition).xyz;"
 "}";

const char* const tunnel_frag =
 "varying vec2 uv;"
 "uniform float time;"
 "uniform sampler2D iChannel0,iChannel1,iChannel2,mask;"
 "varying mat4 mview;"
 "varying float znear,zfar,nearPlane,farPlane;"
 "varying mat4 pmat;"
 "uniform vec3 sky1,sky2,lig,cube,objectPos;"
 "uniform float objectMix;"
 "varying vec3 cameraPosition;"
 "varying float nearPlanePosition;"
 "varying vec3 viewDirection;"
 "varying mat4 mviewproj;\n"
 "#define pi2 6.28318530718\n"
 "const float precis=.015;"
 "uniform vec2 g_resolution;\n"
 "#define FAR 40.\n"
 "float hash(float n)"
 "{"
   "return fract(cos(n)*45758.5);"
 "}"
 "vec3 tex3D(sampler2D tex,in vec3 p,in vec3 n)"
 "{"
   "n=max(n*n,.001);"
   "n/=n.x+n.y+n.z;"
   "return(texture2D(tex,p.yz)*n.x+texture2D(tex,p.zx)*n.y+texture2D(tex,p.xy)*n.z).xyz;"
 "}"
 "float sminP(float a,float b,float smoothing)"
 "{"
   "float h=clamp(.5+.5*(b-a)/smoothing,0.,1.);"
   "return mix(b,a,h)-smoothing*h*(1.-h);"
 "}"
 "float map(vec3 q)"
 "{"
   "vec3 p=abs(fract(q/3.)*3.-1.5);"
   "float d=min(max(p.x,p.y),min(max(p.y,p.z),max(p.x,p.z)))-1.+.05;"
   "p=abs(fract(q)-.5);"
   "d=max(d,min(max(p.x,p.y),min(max(p.y,p.z),max(p.x,p.z)))-1./3.+.05);"
   "p=abs(fract(q*2.)*.5-.25);"
   "d=max(d,min(max(p.x,p.y),min(max(p.y,p.z),max(p.x,p.z)))-.5/3.-.015);"
   "p=abs(fract(q*3./.5)*.5/3.-.5/6.);"
   "return max(d,min(max(p.x,p.y),min(max(p.y,p.z),max(p.x,p.z)))-1./18.-.015);"
 "}"
 "float trace(vec3 ro,vec3 rd)"
 "{"
   "float t=0.,d;"
   "for(int i=0;i<64;i++)"
     "{"
       "d=map(ro+rd*t);"
       "if(d<.0025*t||t>FAR)"
         "break;"
       "t+=d;"
     "}"
   "return t;"
 "}"
 "float refTrace(vec3 ro,vec3 rd)"
 "{"
   "float t=0.,d;"
   "for(int i=0;i<16;i++)"
     "{"
       "d=map(ro+rd*t);"
       "if(d<.0025*t||t>FAR)"
         "break;"
       "t+=d;"
     "}"
   "return t;"
 "}"
 "vec3 normal(in vec3 p)"
 "{"
   "vec2 e=vec2(.005,-.005);"
   "return normalize(e.xyy*map(p+e.xyy)+e.yyx*map(p+e.yyx)+e.yxy*map(p+e.yxy)+e.xxx*map(p+e.xxx));"
 "}"
 "float calculateAO(in vec3 p,in vec3 n)"
 "{"
   "float ao=0.,l;"
   "const float nbIte=6.,falloff=1.,maxDist=1.;"
   "for(float i=1.;i<nbIte+.5;i++)"
     "{"
       "l=(i+hash(i))*.5/nbIte*maxDist;"
       "ao+=(l-map(p+n*l))/pow(1.+l,falloff);"
     "}"
   "return clamp(1.-ao/nbIte,0.,1.);"
 "}"
 "float softShadow(vec3 ro,vec3 lp,float k)"
 "{"
   "const int maxIterationsShad=16;"
   "vec3 rd=lp-ro;"
   "float shade=1.,dist=.05,end=max(length(rd),.001),stepDist=end/float(maxIterationsShad);"
   "rd/=end;"
   "for(int i=0;i<maxIterationsShad;i++)"
     "{"
       "float h=map(ro+rd*dist);"
       "shade=min(shade,smoothstep(0.,1.,k*h/dist));"
       "dist+=clamp(h,.02,.25);"
       "if(h<.001||dist>end)"
         "break;"
     "}"
   "return min(max(shade,0.)+.5,1.);"
 "}"
 "void main()"
 "{"
   "vec3 ro=vec3(0.,0.,time),rd=vec3(2.*gl_FragCoord.xy-g_resolution.xy,g_resolution.y);"
   "rd=normalize(vec3(rd.xy,sqrt(max(rd.z*rd.z-dot(rd.xy,rd.xy)*.2,0.))));"
   "vec3 lp=ro+vec3(0.,1.,0.);"
   "vec2 m=sin(vec2(0,1.5708)+time/4.);"
   "rd.xy=mat2(m.y,-m.x,m)*rd.xy;"
   "rd.xz=mat2(m.y,-m.x,m)*rd.xz;"
   "vec3 col=vec3(0);"
   "float t=trace(ro,rd);"
   "if(t<FAR)"
     "{"
       "vec3 sp=ro+rd*t,sn=normal(sp),ref=reflect(rd,sn);"
       "const float ts=2.;"
       "vec3 oCol=tex3D(iChannel0,sp*ts,sn),q=abs(mod(sp,3.)-1.5);"
       "if(max(max(q.x,q.y),q.z)<1.063)"
         "oCol=oCol*vec3(.7,.85,1.);"
       "oCol=smoothstep(0.,1.,oCol);"
       "float sh=softShadow(sp,lp,16.),ao=calculateAO(sp,sn);"
       "vec3 ld=lp-sp;"
       "float lDist=max(length(ld),.001);"
       "ld/=lDist;"
       "float diff=max(dot(ld,sn),0.),spec=pow(max(dot(reflect(-ld,sn),-rd),0.),12.),atten=1./(1.+lDist*.25+lDist*lDist*.1);"
       "diff+=max(dot(-rd,sn),0.)*.45;"
       "spec+=pow(max(dot(reflect(rd,sn),-rd),0.),12.)*.45;"
       "float rt=refTrace(sp+ref*.1,ref);"
       "vec3 rsp=sp+ref*rt,rsn=normal(rsp),rCol=tex3D(iChannel0,rsp*ts,rsn);"
       "q=abs(mod(rsp,3.)-1.5);"
       "if(max(max(q.x,q.y),q.z)<1.063)"
         "rCol=rCol*vec3(.7,.85,1.);"
       "rCol=sqrt(rCol);"
       "float rDiff=max(dot(rsn,normalize(lp-rsp)),0.);"
       "rDiff+=max(dot(rsn,normalize(-rd-rsp)),0.)*.45;"
       "float rlDist=length(lp-rsp),rAtten=1./(1.+rlDist*.25+rlDist*rlDist*.1);"
       "rCol=min(rCol,1.)*(rDiff+vec3(.5,.6,.7))*rAtten;"
       "col=oCol*(diff+vec3(.5,.6,.7))+vec3(.5,.7,1)*spec*2.+rCol*.25;"
       "col=min(col*atten*sh*ao,1.);"
     "}"
   "col=mix(col,vec3(.55,.75,1.),smoothstep(0.,FAR-15.,t));"
   "gl_FragColor=vec4(vec3(col),1.);"
 "}";

const char* const text_vert =
 "varying vec3 cameraPosition,viewDirection;"
 "varying mat4 pmat,mview,mviewproj;"
 "void main()"
 "{"
   "gl_Position=gl_Vertex;"
   "vec4 v=gl_Vertex;"
   "v=gl_ProjectionMatrixInverse*v;"
   "v/=v.w;"
   "v=gl_ModelViewMatrixInverse*v;"
   "vec4 nearPlanePosition=v/v.w;"
   "mview=gl_ModelViewMatrix;"
   "mviewproj=gl_ModelViewProjectionMatrix;"
   "pmat=gl_ProjectionMatrix;"
   "cameraPosition=(gl_ModelViewMatrixInverse*vec4(0.,0.,0.,1.)).xyz;"
   "viewDirection=normalize(nearPlanePosition-cameraPosition).xyz;"
 "}";

const char* const text_frag =
 "varying vec2 uv;"
 "uniform float time;"
 "uniform vec2 pixels[512];"
 "uniform int numPix;"
 "uniform sampler2D iChannel0,iChannel1,iChannel2,mask;"
 "varying mat4 mview;"
 "varying float znear,zfar,nearPlane,farPlane;"
 "varying mat4 pmat;"
 "uniform vec3 sky1,sky2,lig,cube,objectPos;"
 "uniform float objectMix;"
 "varying vec3 cameraPosition;"
 "varying float nearPlanePosition;"
 "varying vec3 viewDirection;"
 "varying mat4 mviewproj;\n"
 "#define pi2 6.28318530718\n"
 "const float precis=.015;"
 "uniform vec2 g_resolution;struct hitInfo{int materialId;};"
 "float hash(float n)"
 "{"
   "return fract(sin(n)*43758.5);"
 "}"
 "float noise(in vec3 x)"
 "{"
   "vec3 p=floor(x),f=fract(x);"
   "float a=texture2D(iChannel0,x.xy/256.+p.z*120.712).x,b=texture2D(iChannel0,x.xy/256.+(p.z+1.)*120.712).x;"
   "return mix(a,b,f.z);"
 "}"
 "const mat3 m=mat3(0.,.8,.6,-.8,.36,-.48,-.6,-.48,.64);"
 "float noise(in vec2 x)"
 "{"
   "vec2 p=floor(x),f=fract(x),uv=p.xy+f.xy*f.xy*(3.-2.*f.xy);"
   "return-1.+2.*texture2D(iChannel0,(uv+.5)/256.,-100.).x;"
 "}"
 "vec3 texturize(sampler2D sa,vec3 p,vec3 n)"
 "{"
   "vec3 x=texture2D(sa,p.yz).xyz,y=texture2D(sa,p.zx).xyz,z=texture2D(sa,p.xy).xyz;"
   "return x*abs(n.x)+y*abs(n.y)+z*abs(n.z);"
 "}"
 "float fbm(vec3 p)"
 "{"
   "float f;"
   "f=.5*noise(p);"
   "p=m*p*2.02;"
   "f+=.25*noise(p);"
   "p=m*p*2.03;"
   "f+=.125*noise(p);"
   "p=m*p*2.01;"
   "f+=.0625*noise(p);"
   "return f;"
 "}"
 "mat3 rotz(in float a)"
 "{"
   "float ca=cos(a),sa=sin(a);"
   "return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.);"
 "}"
 "mat3 rotx(in float a)"
 "{"
   "float ca=cos(a),sa=sin(a);"
   "return mat3(1.,0.,0.,0.,ca,-sa,0.,sa,ca);"
 "}"
 "mat3 roty(in float a)"
 "{"
   "float ca=cos(a),sa=sin(a);"
   "return mat3(ca,0.,sa,0.,1.,0.,-sa,0.,ca);"
 "}"
 "vec2 opUnion(vec2 d1,vec2 d2)"
 "{"
   "return d1.x<d2.x?d1:d2;"
 "}"
 "float opSub(float d1,float d2)"
 "{"
   "return max(-d2,d1);"
 "}"
 "vec3 opRep(vec3 p,vec3 c)"
 "{"
   "return mod(p,c)-.5*c;"
 "}"
 "float length2(vec2 p)"
 "{"
   "return sqrt(p.x*p.x+p.y*p.y);"
 "}"
 "float length6(vec2 p)"
 "{"
   "p=p*p*p;"
   "p=p*p;"
   "return pow(p.x+p.y,1./6.);"
 "}"
 "float length8(vec2 p)"
 "{"
   "p=p*p;"
   "p=p*p;"
   "p=p*p;"
   "return pow(p.x+p.y,.125);"
 "}"
 "float sdTorus82(vec3 p,vec2 t)"
 "{"
   "vec2 q=vec2(length2(p.xz)-t.x,p.y);"
   "return length8(q)-t.y;"
 "}"
 "float sdCylinder(vec3 p,vec2 h)"
 "{"
   "return max(length(p.xz)-h.x,abs(p.y)-h.y);"
 "}"
 "float udRoundBox(vec3 pos,vec3 size,float r)"
 "{"
   "return length(max(abs(pos)-size,0.))-r;"
 "}"
 "float sdBox(vec3 p,vec3 b)"
 "{"
   "vec3 d=abs(p)-b;"
   "return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));"
 "}"
 "float sdCone(vec3 p,vec2 c)"
 "{"
   "float q=length(p.xz);"
   "return max(dot(c,vec2(q,p.y)),p.y);"
 "}"
 "float sdSphere(in vec3 p,in vec4 e)"
 "{"
   "vec3 di=p-e.xyz;"
   "return length(di)-e.w;"
 "}"
 "vec3 opTwist(vec3 p)"
 "{"
   "float c=cos(10.*p.y+10.),s=sin(10.*p.y+10.);"
   "mat2 m=mat2(c,-s,s,c);"
   "return vec3(m*p.xz,p.y);"
 "}"
 "vec2 sdSegment(vec3 a,vec3 b,vec3 p)"
 "{"
   "vec3 pa=p-a,ba=b-a;"
   "float h=clamp(dot(pa,ba)/dot(ba,ba),0.,1.);"
   "return vec2(length(pa-ba*h),h);"
 "}"
 "float smin(float a,float b)"
 "{"
   "float k=.06,h=clamp(.5+.5*(b-a)/k,0.,1.);"
   "return mix(b,a,h)-k*h*(1.-h);"
 "}"
 "float smin(float a,float b,float k)"
 "{"
   "float h=clamp(.5+.5*(b-a)/k,0.,1.);"
   "return mix(b,a,h)-k*h*(1.-h);"
 "}"
 "vec2 smin(vec2 a,vec2 b)"
 "{"
   "float k=1.6,h=clamp(.5+.5*(b.x-a.x)/k,0.,1.);"
   "return mix(b,a,h)-k*h*(1.-h);"
 "}"
 "float sdCylinder6(vec3 p,vec2 h)"
 "{"
   "return max(length6(p.xz)-h.x,abs(p.y)-h.y);"
 "}"
 "float sdCapsule(vec3 p,vec3 a,vec3 b,float r)"
 "{"
   "vec3 pa=p-a,ba=b-a;"
   "float h=clamp(dot(pa,ba)/dot(ba,ba),0.,1.);"
   "return length(pa-ba*h)-r;"
 "}\n"
 "#define MAT_NONE 0.0\n"
 "#define MAT_DBF 1.0\n"
 "#define MAT_GROUND 2.0\n"
 "#define MAT_TREE 3.0\n"
 "#define MAT_SNOW 4.0\n"
 "#define MAT_HAT 5.0\n"
 "#define MAT_EYE 6.0\n"
 "#define MAT_BODY 7.0\n"
 "#define MAT_NOSE 8.0\n"
 "#define MAT_ARM 9.0\n"
 "#define MAT_D 10.0\n"
 "#define MAT_B 11.0\n"
 "#define MAT_F 12.0\n"
 "vec2 map(in vec3 p,in bool masked)"
 "{"
   "vec2 res=vec2(1000.,-1.);"
   "float h=0,dd=p.y-h;"
   "res=vec2(dd,0.);"
   "float dis=100000.;"
   "res.x=min(dis,res.x);"
   "res.y=MAT_SNOW;"
   "res.x=dis;"
   "for(int i=0;i<numPix;i++)"
     "{"
       "vec3 p2=p+vec3(pixels[i].x,0.,0.);"
       "float dist=sdBox(p2,vec3(10.));"
       "res.x=min(res.x,dist);"
     "}"
   "return res;"
 "}"
 "vec3 intersect(in vec3 ro,in vec3 rd,in bool masked)"
 "{"
   "float maxd=500.,dist=precis*1.5,t=0.,d=0.,m=1.;"
   "for(int steps=0;steps<150;steps++)"
     "{"
       "if(abs(dist)<precis||t>maxd)"
         "continue;"
       "t+=dist;"
       "vec2 res=map(ro+rd*t,masked);"
       "dist=res.x;"
       "d=res.y;"
       "m=res.y;"
     "}"
   "if(t>maxd)"
     "m=-1.;"
   "return vec3(t,d,m);"
 "}"
 "vec3 calcNormal(in vec3 pos,in float prec,in bool masked)"
 "{"
   "vec3 eps=vec3(prec,0.,0.);"
   "return normalize(vec3(map(pos+eps.xyy,masked).x-map(pos-eps.xyy,masked).x,map(pos+eps.yxy,masked).x-map(pos-eps.yxy,masked).x,map(pos+eps.yyx,masked).x-map(pos-eps.yyx,masked).x));"
 "}"
 "vec3 calcNormal(in vec3 pos,in bool masked)"
 "{"
   "vec3 eps=vec3(precis,0.,0.);"
   "return normalize(vec3(map(pos+eps.xyy,masked).x-map(pos-eps.xyy,masked).x,map(pos+eps.yxy,masked).x-map(pos-eps.yxy,masked).x,map(pos+eps.yyx,masked).x-map(pos-eps.yyx,masked).x));"
 "}"
 "float softshadow(in vec3 ro,in vec3 rd,in float k,in bool masked)"
 "{"
   "float res=1.,t=0.,h=1.;"
   "for(int i=0;i<60;i++)"
     "{"
       "h=map(ro+rd*t,masked).x;"
       "res=min(res,k*h/t);"
       "t+=clamp(h,.02,1.);"
     "}"
   "return clamp(res,0.,1.);"
 "}"
 "float calcOcc(in vec3 pos,in vec3 nor,in bool masked)"
 "{"
   "float totao=0.;"
   "for(int aoi=0;aoi<8;aoi++)"
     "{"
       "float hr=.1+1.5*pow(float(aoi)/8.,2.);"
       "vec3 aopos=pos+nor*hr;"
       "float dd=map(aopos,masked).x;"
       "totao+=max(0.,hr-3.*dd-.01);"
     "}"
   "return clamp(1.-.15*totao,0.,1.);"
 "}"
 "vec3 background(vec3 p,vec3 d)"
 "{"
   "vec3 color=mix(sky1,sky2,d.y*.5+.5);"
   "return color*(noise(d)+.3*pow(noise(d*4.),2.));"
 "}"
 "void shade(in vec3 pos,in vec3 nor,in vec3 rd,in float matID,out vec3 bnor,out vec4 mate,out vec2 mate2)"
 "{"
   "bnor=vec3(0.);"
   "mate=vec4(0.);"
   "mate2=vec2(0.);"
   "vec3 snowTint=vec3(1.,1.,1.);"
   "if(matID==MAT_D)"
     "{"
       "snowTint=vec3(1.,1.,0.);"
     "}"
   "else"
     " if(matID==MAT_B)"
       "{"
         "snowTint=vec3(0.,1.,0.);"
       "}"
     "else"
       " if(matID==MAT_F)"
         "{"
           "snowTint=vec3(1.,0.,0.);"
         "}"
   "if(matID==MAT_HAT)"
     "{"
       "mate.xyz=vec3(.2,.3,.2);"
       "float iss=smoothstep(.2,.5,nor.y);"
       "vec3 snowColor=vec3(.65,.8,.8),cnor=normalize(-1.+2.*texture2D(iChannel0,.65*pos.xz).xyz);"
       "cnor.y=abs(cnor.y);"
       "float spe=max(0.,pow(clamp(dot(lig,reflect(rd,cnor)),0.,1.),16.));"
       "mate2.y=spe*iss;"
       "mate.xyz=mix(mate.xyz,snowColor,iss);"
     "}"
   "else"
     " if(matID==MAT_NOSE)"
       "{"
         "mate.xyz=vec3(.2,.175,.2);"
         "float iss=smoothstep(.2,.9,nor.y);"
         "iss=mix(iss,.2,.75*smoothstep(.9,1.,texturize(iChannel1,.1*pos,nor).x));"
         "vec3 snowColor=vec3(.65,.8,.8),cnor=normalize(-1.+2.*texture2D(iChannel0,.65*pos.xz).xyz);"
         "cnor.y=abs(cnor.y);"
         "float spe=max(0.,pow(clamp(dot(lig,reflect(rd,cnor)),0.,1.),16.));"
         "mate.y=spe*iss;"
         "mate.xyz=mix(mate.xyz,snowColor,iss);"
       "}"
     "else"
       " if(matID==MAT_EYE)"
         "{"
           "mate.xyz=vec3(.1,.1,.1);"
           "float iss=smoothstep(.2,.9,nor.y);"
           "vec3 snowColor=vec3(.65,.8,.8),cnor=normalize(-1.+2.*texture2D(iChannel0,.65*pos.xz).xyz);"
           "cnor.y=abs(cnor.y);"
           "float spe=max(0.,pow(clamp(dot(lig,reflect(rd,cnor)),0.,1.),16.));"
           "mate.y=spe*iss;"
           "mate.xyz=mix(mate.xyz,snowColor,iss*.5);"
         "}"
       "else"
         " if(matID==MAT_ARM)"
           "{"
             "mate.xyz=vec3(.4,.25,.2);"
             "float iss=smoothstep(.2,.5,nor.y);"
             "vec3 snowColor=vec3(.65,.8,.8),cnor=normalize(-1.+2.*texture2D(iChannel0,.65*pos.xz).xyz);"
             "cnor.y=abs(cnor.y);"
             "float spe=max(0.,pow(clamp(dot(lig,reflect(rd,cnor)),0.,1.),16.));"
             "mate.y=spe*iss;"
             "mate.xyz=mix(mate.xyz,snowColor,iss*.5);"
           "}"
         "else"
           "{"
             "mate.xyz=vec3(.1,.1,.1);"
             "float iss=smoothstep(.2,.5,nor.y);"
             "mate.xyz=vec3(.8,.8,.8)*snowTint;"
             "vec3 cnor=normalize(-1.+2.*texture2D(iChannel0,.65*pos.xz).xyz);"
             "cnor.y=abs(cnor.y);"
             "float spe=max(0.,pow(clamp(dot(lig,reflect(rd,cnor)),0.,1.),16.));"
             "mate.xyz=spe*iss;"
             "mate.xyz=mix(mate.xyz,vec3(.8),iss);"
             "mate.xyz+=sky1*cnor.y*1;"
             "mate.xyz+=sky2*cnor.y*1;"
           "}"
 "}"
 "float cloudShadow(in vec3 pos)"
 "{"
   "vec2 cuv=pos.xz+lig.xz*(100.-pos.y)/lig.y;"
   "float cc=.1+.9*smoothstep(.1,.35,texture2D(iChannel1,.0001*cuv+.1+.013*time).x);"
   "return cc;"
 "}"
 "vec3 snow(vec3 ro,vec3 rd)"
 "{"
   "return vec3(1.,1.,1.);"
 "}"
 "void main()"
 "{"
   "vec2 iMouse=vec2(0.,0.),fp=gl_FragCoord.xy/g_resolution.xy;"
   "bool masked=texture2D(mask,fp).x>.001;"
   "vec2 xy=-1.+2.*fp,s=xy*vec2(1.75,1.);"
   "float time=time*.15+2.*iMouse.x/g_resolution.x;"
   "vec3 ro=cameraPosition,rd=normalize(viewDirection);"
   "float ctime=time;"
   "vec3 tmat=intersect(ro,rd,masked),d=vec3(xy,1.),col=2.5*background(ro+tmat.x*rd,d)-rd.y*1.5;"
   "float sun=clamp(dot(rd,lig),0.,1.);"
   "vec3 bgcol=col;"
   "float depth=1.;"
   "if(tmat.z>-.5)"
     "{"
       "vec3 pos=ro+tmat.x*rd,nor=tmat.z==MAT_SNOW?calcNormal(pos,masked):calcNormal(pos,masked);"
       "vec4 mate=vec4(0.);"
       "vec2 mate2=vec2(0.);"
       "vec3 bnor=vec3(0.);"
       "shade(pos,nor,rd,tmat.z,bnor,mate,mate2);"
       "nor=normalize(nor+bnor);"
       "vec3 ref=reflect(rd,nor);"
       "float occ=calcOcc(pos,nor,masked)*clamp(.7+.3*nor.y,0.,1.),sky=.6+.4*nor.y,bou=clamp(-nor.y,0.,1.),dif=max(dot(nor,lig),0.),bac=max(.2+.8*dot(nor,normalize(vec3(-lig.x,0.,-lig.z))),0.),sha=0.;"
       "if(dif>.01)"
         "sha=softshadow(pos+.01*nor,lig,64.,masked);"
       "sha*=cloudShadow(pos);"
       "float fre=pow(clamp(1.+dot(nor,rd),0.,1.),3.);"
       "vec3 lin=vec3(0.);"
       "lin+=dif*vec3(1.7,1.15,.7)*pow(vec3(sha),vec3(1.,1.2,2.));"
       "lin+=sky*vec3(.25,.2,.25)*occ;"
       "lin+=1.2*bou*vec3(.15,.2,.2)*(.5+.5*occ);"
       "lin+=fre*vec3(1.,1.25,1.3)*occ*.5*(.5+.5*dif*sha);"
       "lin+=mate2.y*vec3(1.,.6,.5)*4.*occ*dif*(.1+.9*sha);"
       "col=mate.xyz*lin;"
       "col=mix(bgcol,col,exp(-.0015*pow(tmat.x,1.)));"
       "vec4 worldHitPos=mviewproj*vec4(pos,1.);"
       "float zc=worldHitPos.z,wc=worldHitPos.w;"
       "depth=zc/wc;"
       "depth=(depth+1.)/2.;"
     "}"
   "col+=vec3(1.,.6,.2)*.4*pow(sun,4.);"
   "col=pow(clamp(col,0.,1.),vec3(.45));"
   "gl_FragDepth=depth;"
   "gl_FragColor=vec4(vec3(col),1.);"
 "}";

const char* const terrainTest_vert =
 "varying vec3 cameraPosition,viewDirection;"
 "varying mat4 pmat,mview,mviewproj;"
 "void main()"
 "{"
   "gl_Position=gl_Vertex;"
   "vec4 v=gl_Vertex;"
   "v=gl_ProjectionMatrixInverse*v;"
   "v/=v.w;"
   "v=gl_ModelViewMatrixInverse*v;"
   "vec4 nearPlanePosition=v/v.w;"
   "mview=gl_ModelViewMatrix;"
   "mviewproj=gl_ModelViewProjectionMatrix;"
   "pmat=gl_ProjectionMatrix;"
   "cameraPosition=(gl_ModelViewMatrixInverse*vec4(0.,0.,0.,1.)).xyz;"
   "viewDirection=normalize(nearPlanePosition-cameraPosition).xyz;"
 "}";

const char* const terrainTest_frag =
 "varying vec2 uv;"
 "uniform float time;"
 "uniform sampler2D iChannel0,iChannel1,iChannel2,mask;"
 "varying mat4 mview;"
 "varying float znear,zfar,nearPlane,farPlane;"
 "varying mat4 pmat;"
 "uniform vec3 sky1,sky2,lig,cube,objectPos;"
 "uniform float objectMix;"
 "varying vec3 cameraPosition;"
 "varying float nearPlanePosition;"
 "varying vec3 viewDirection;"
 "varying mat4 mviewproj;\n"
 "#define pi2 6.28318530718\n"
 "const float precis=.015;"
 "uniform vec2 g_resolution;struct hitInfo{int materialId;};"
 "float hash(float n)"
 "{"
   "return fract(sin(n)*43758.5);"
 "}"
 "float noise(in vec3 x)"
 "{"
   "vec3 p=floor(x),f=fract(x);"
   "float a=texture2D(iChannel0,x.xy/256.+p.z*120.712).x,b=texture2D(iChannel0,x.xy/256.+(p.z+1.)*120.712).x;"
   "return mix(a,b,f.z);"
 "}"
 "const mat3 m=mat3(0.,.8,.6,-.8,.36,-.48,-.6,-.48,.64);"
 "float noise(in vec2 x)"
 "{"
   "vec2 p=floor(x),f=fract(x),uv=p.xy+f.xy*f.xy*(3.-2.*f.xy);"
   "return-1.+2.*texture2D(iChannel0,(uv+.5)/256.,-100.).x;"
 "}"
 "vec3 texturize(sampler2D sa,vec3 p,vec3 n)"
 "{"
   "vec3 x=texture2D(sa,p.yz).xyz,y=texture2D(sa,p.zx).xyz,z=texture2D(sa,p.xy).xyz;"
   "return x*abs(n.x)+y*abs(n.y)+z*abs(n.z);"
 "}"
 "float fbm(vec3 p)"
 "{"
   "float f;"
   "f=.5*noise(p);"
   "p=m*p*2.02;"
   "f+=.25*noise(p);"
   "p=m*p*2.03;"
   "f+=.125*noise(p);"
   "p=m*p*2.01;"
   "f+=.0625*noise(p);"
   "return f;"
 "}"
 "mat3 rotz(in float a)"
 "{"
   "float ca=cos(a),sa=sin(a);"
   "return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.);"
 "}"
 "mat3 rotx(in float a)"
 "{"
   "float ca=cos(a),sa=sin(a);"
   "return mat3(1.,0.,0.,0.,ca,-sa,0.,sa,ca);"
 "}"
 "mat3 roty(in float a)"
 "{"
   "float ca=cos(a),sa=sin(a);"
   "return mat3(ca,0.,sa,0.,1.,0.,-sa,0.,ca);"
 "}"
 "vec2 opUnion(vec2 d1,vec2 d2)"
 "{"
   "return d1.x<d2.x?d1:d2;"
 "}"
 "float opSub(float d1,float d2)"
 "{"
   "return max(-d2,d1);"
 "}"
 "vec3 opRep(vec3 p,vec3 c)"
 "{"
   "return mod(p,c)-.5*c;"
 "}"
 "float length2(vec2 p)"
 "{"
   "return sqrt(p.x*p.x+p.y*p.y);"
 "}"
 "float length6(vec2 p)"
 "{"
   "p=p*p*p;"
   "p=p*p;"
   "return pow(p.x+p.y,1./6.);"
 "}"
 "float length8(vec2 p)"
 "{"
   "p=p*p;"
   "p=p*p;"
   "p=p*p;"
   "return pow(p.x+p.y,.125);"
 "}"
 "float sdTorus82(vec3 p,vec2 t)"
 "{"
   "vec2 q=vec2(length2(p.xz)-t.x,p.y);"
   "return length8(q)-t.y;"
 "}"
 "float sdCylinder(vec3 p,vec2 h)"
 "{"
   "return max(length(p.xz)-h.x,abs(p.y)-h.y);"
 "}"
 "float udRoundBox(vec3 pos,vec3 size,float r)"
 "{"
   "return length(max(abs(pos)-size,0.))-r;"
 "}"
 "float sdBox(vec3 p,vec3 b)"
 "{"
   "vec3 d=abs(p)-b;"
   "return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));"
 "}"
 "float sdCone(vec3 p,vec2 c)"
 "{"
   "float q=length(p.xz);"
   "return max(dot(c,vec2(q,p.y)),p.y);"
 "}"
 "float sdSphere(in vec3 p,in vec4 e)"
 "{"
   "vec3 di=p-e.xyz;"
   "return length(di)-e.w;"
 "}"
 "vec3 opTwist(vec3 p)"
 "{"
   "float c=cos(10.*p.y+10.),s=sin(10.*p.y+10.);"
   "mat2 m=mat2(c,-s,s,c);"
   "return vec3(m*p.xz,p.y);"
 "}"
 "vec2 sdSegment(vec3 a,vec3 b,vec3 p)"
 "{"
   "vec3 pa=p-a,ba=b-a;"
   "float h=clamp(dot(pa,ba)/dot(ba,ba),0.,1.);"
   "return vec2(length(pa-ba*h),h);"
 "}"
 "float smin(float a,float b)"
 "{"
   "float k=.06,h=clamp(.5+.5*(b-a)/k,0.,1.);"
   "return mix(b,a,h)-k*h*(1.-h);"
 "}"
 "float smin(float a,float b,float k)"
 "{"
   "float h=clamp(.5+.5*(b-a)/k,0.,1.);"
   "return mix(b,a,h)-k*h*(1.-h);"
 "}"
 "vec2 smin(vec2 a,vec2 b)"
 "{"
   "float k=1.6,h=clamp(.5+.5*(b.x-a.x)/k,0.,1.);"
   "return mix(b,a,h)-k*h*(1.-h);"
 "}"
 "float sdCylinder6(vec3 p,vec2 h)"
 "{"
   "return max(length6(p.xz)-h.x,abs(p.y)-h.y);"
 "}"
 "float sdCapsule(vec3 p,vec3 a,vec3 b,float r)"
 "{"
   "vec3 pa=p-a,ba=b-a;"
   "float h=clamp(dot(pa,ba)/dot(ba,ba),0.,1.);"
   "return length(pa-ba*h)-r;"
 "}\n"
 "#define MAT_NONE 0.0\n"
 "#define MAT_DBF 1.0\n"
 "#define MAT_GROUND 2.0\n"
 "#define MAT_TREE 3.0\n"
 "#define MAT_SNOW 4.0\n"
 "#define MAT_HAT 5.0\n"
 "#define MAT_EYE 6.0\n"
 "#define MAT_BODY 7.0\n"
 "#define MAT_NOSE 8.0\n"
 "#define MAT_ARM 9.0\n"
 "#define MAT_D 10.0\n"
 "#define MAT_B 11.0\n"
 "#define MAT_F 12.0\n"
 "vec2 map(in vec3 p,in bool masked)"
 "{"
   "vec2 res=vec2(1000.,-1.);"
   "float h=0,dd=p.y-h;"
   "res=vec2(dd,0.);"
   "float dis=100000.;"
   "res.x=min(dis,res.x);"
   "res.y=MAT_SNOW;"
   "res.x=sdBox(p,vec3(10.));"
   "return res;"
 "}"
 "vec3 intersect(in vec3 ro,in vec3 rd,in bool masked)"
 "{"
   "float maxd=500.,dist=precis*1.5,t=0.,d=0.,m=1.;"
   "for(int steps=0;steps<150;steps++)"
     "{"
       "if(abs(dist)<precis||t>maxd)"
         "continue;"
       "t+=dist;"
       "vec2 res=map(ro+rd*t,masked);"
       "dist=res.x;"
       "d=res.y;"
       "m=res.y;"
     "}"
   "if(t>maxd)"
     "m=-1.;"
   "return vec3(t,d,m);"
 "}"
 "vec3 calcNormal(in vec3 pos,in float prec,in bool masked)"
 "{"
   "vec3 eps=vec3(prec,0.,0.);"
   "return normalize(vec3(map(pos+eps.xyy,masked).x-map(pos-eps.xyy,masked).x,map(pos+eps.yxy,masked).x-map(pos-eps.yxy,masked).x,map(pos+eps.yyx,masked).x-map(pos-eps.yyx,masked).x));"
 "}"
 "vec3 calcNormal(in vec3 pos,in bool masked)"
 "{"
   "vec3 eps=vec3(precis,0.,0.);"
   "return normalize(vec3(map(pos+eps.xyy,masked).x-map(pos-eps.xyy,masked).x,map(pos+eps.yxy,masked).x-map(pos-eps.yxy,masked).x,map(pos+eps.yyx,masked).x-map(pos-eps.yyx,masked).x));"
 "}"
 "float softshadow(in vec3 ro,in vec3 rd,in float k,in bool masked)"
 "{"
   "float res=1.,t=0.,h=1.;"
   "for(int i=0;i<60;i++)"
     "{"
       "h=map(ro+rd*t,masked).x;"
       "res=min(res,k*h/t);"
       "t+=clamp(h,.02,1.);"
     "}"
   "return clamp(res,0.,1.);"
 "}"
 "float calcOcc(in vec3 pos,in vec3 nor,in bool masked)"
 "{"
   "float totao=0.;"
   "for(int aoi=0;aoi<8;aoi++)"
     "{"
       "float hr=.1+1.5*pow(float(aoi)/8.,2.);"
       "vec3 aopos=pos+nor*hr;"
       "float dd=map(aopos,masked).x;"
       "totao+=max(0.,hr-3.*dd-.01);"
     "}"
   "return clamp(1.-.15*totao,0.,1.);"
 "}"
 "vec3 background(vec3 p,vec3 d)"
 "{"
   "vec3 color=mix(sky1,sky2,d.y*.5+.5);"
   "return color*(noise(d)+.3*pow(noise(d*4.),2.));"
 "}"
 "void shade(in vec3 pos,in vec3 nor,in vec3 rd,in float matID,out vec3 bnor,out vec4 mate,out vec2 mate2)"
 "{"
   "bnor=vec3(0.);"
   "mate=vec4(0.);"
   "mate2=vec2(0.);"
   "vec3 snowTint=vec3(1.,1.,1.);"
   "if(matID==MAT_D)"
     "{"
       "snowTint=vec3(1.,1.,0.);"
     "}"
   "else"
     " if(matID==MAT_B)"
       "{"
         "snowTint=vec3(0.,1.,0.);"
       "}"
     "else"
       " if(matID==MAT_F)"
         "{"
           "snowTint=vec3(1.,0.,0.);"
         "}"
   "if(matID==MAT_HAT)"
     "{"
       "mate.xyz=vec3(.2,.3,.2);"
       "float iss=smoothstep(.2,.5,nor.y);"
       "vec3 snowColor=vec3(.65,.8,.8),cnor=normalize(-1.+2.*texture2D(iChannel0,.65*pos.xz).xyz);"
       "cnor.y=abs(cnor.y);"
       "float spe=max(0.,pow(clamp(dot(lig,reflect(rd,cnor)),0.,1.),16.));"
       "mate2.y=spe*iss;"
       "mate.xyz=mix(mate.xyz,snowColor,iss);"
     "}"
   "else"
     " if(matID==MAT_NOSE)"
       "{"
         "mate.xyz=vec3(.2,.175,.2);"
         "float iss=smoothstep(.2,.9,nor.y);"
         "iss=mix(iss,.2,.75*smoothstep(.9,1.,texturize(iChannel1,.1*pos,nor).x));"
         "vec3 snowColor=vec3(.65,.8,.8),cnor=normalize(-1.+2.*texture2D(iChannel0,.65*pos.xz).xyz);"
         "cnor.y=abs(cnor.y);"
         "float spe=max(0.,pow(clamp(dot(lig,reflect(rd,cnor)),0.,1.),16.));"
         "mate.y=spe*iss;"
         "mate.xyz=mix(mate.xyz,snowColor,iss);"
       "}"
     "else"
       " if(matID==MAT_EYE)"
         "{"
           "mate.xyz=vec3(.1,.1,.1);"
           "float iss=smoothstep(.2,.9,nor.y);"
           "vec3 snowColor=vec3(.65,.8,.8),cnor=normalize(-1.+2.*texture2D(iChannel0,.65*pos.xz).xyz);"
           "cnor.y=abs(cnor.y);"
           "float spe=max(0.,pow(clamp(dot(lig,reflect(rd,cnor)),0.,1.),16.));"
           "mate.y=spe*iss;"
           "mate.xyz=mix(mate.xyz,snowColor,iss*.5);"
         "}"
       "else"
         " if(matID==MAT_ARM)"
           "{"
             "mate.xyz=vec3(.4,.25,.2);"
             "float iss=smoothstep(.2,.5,nor.y);"
             "vec3 snowColor=vec3(.65,.8,.8),cnor=normalize(-1.+2.*texture2D(iChannel0,.65*pos.xz).xyz);"
             "cnor.y=abs(cnor.y);"
             "float spe=max(0.,pow(clamp(dot(lig,reflect(rd,cnor)),0.,1.),16.));"
             "mate.y=spe*iss;"
             "mate.xyz=mix(mate.xyz,snowColor,iss*.5);"
           "}"
         "else"
           "{"
             "mate.xyz=vec3(.1,.1,.1);"
             "float iss=smoothstep(.2,.5,nor.y);"
             "mate.xyz=vec3(.8,.8,.8)*snowTint;"
             "vec3 cnor=normalize(-1.+2.*texture2D(iChannel0,.65*pos.xz).xyz);"
             "cnor.y=abs(cnor.y);"
             "float spe=max(0.,pow(clamp(dot(lig,reflect(rd,cnor)),0.,1.),16.));"
             "mate.xyz=spe*iss;"
             "mate.xyz=mix(mate.xyz,vec3(.8),iss);"
             "mate.xyz+=sky1*cnor.y*1;"
             "mate.xyz+=sky2*cnor.y*1;"
           "}"
 "}"
 "float cloudShadow(in vec3 pos)"
 "{"
   "vec2 cuv=pos.xz+lig.xz*(100.-pos.y)/lig.y;"
   "float cc=.1+.9*smoothstep(.1,.35,texture2D(iChannel1,.0001*cuv+.1+.013*time).x);"
   "return cc;"
 "}"
 "vec3 snow(vec3 ro,vec3 rd)"
 "{"
   "return vec3(1.,1.,1.);"
 "}"
 "void main()"
 "{"
   "vec2 iMouse=vec2(0.,0.),fp=gl_FragCoord.xy/g_resolution.xy;"
   "bool masked=texture2D(mask,fp).x>.001;"
   "vec2 xy=-1.+2.*fp,s=xy*vec2(1.75,1.);"
   "float time=time*.15+2.*iMouse.x/g_resolution.x;"
   "vec3 ro=cameraPosition,rd=normalize(viewDirection);"
   "float ctime=time;"
   "vec3 tmat=intersect(ro,rd,masked),d=vec3(xy,1.),col=2.5*background(ro+tmat.x*rd,d)-rd.y*1.5;"
   "float sun=clamp(dot(rd,lig),0.,1.);"
   "vec3 bgcol=col;"
   "float depth=1.;"
   "if(tmat.z>-.5)"
     "{"
       "vec3 pos=ro+tmat.x*rd,nor=tmat.z==MAT_SNOW?calcNormal(pos,masked):calcNormal(pos,masked);"
       "vec4 mate=vec4(0.);"
       "vec2 mate2=vec2(0.);"
       "vec3 bnor=vec3(0.);"
       "shade(pos,nor,rd,tmat.z,bnor,mate,mate2);"
       "nor=normalize(nor+bnor);"
       "vec3 ref=reflect(rd,nor);"
       "float occ=calcOcc(pos,nor,masked)*clamp(.7+.3*nor.y,0.,1.),sky=.6+.4*nor.y,bou=clamp(-nor.y,0.,1.),dif=max(dot(nor,lig),0.),bac=max(.2+.8*dot(nor,normalize(vec3(-lig.x,0.,-lig.z))),0.),sha=0.;"
       "if(dif>.01)"
         "sha=softshadow(pos+.01*nor,lig,64.,masked);"
       "sha*=cloudShadow(pos);"
       "float fre=pow(clamp(1.+dot(nor,rd),0.,1.),3.);"
       "vec3 lin=vec3(0.);"
       "lin+=dif*vec3(1.7,1.15,.7)*pow(vec3(sha),vec3(1.,1.2,2.));"
       "lin+=sky*vec3(.25,.2,.25)*occ;"
       "lin+=1.2*bou*vec3(.15,.2,.2)*(.5+.5*occ);"
       "lin+=fre*vec3(1.,1.25,1.3)*occ*.5*(.5+.5*dif*sha);"
       "lin+=mate2.y*vec3(1.,.6,.5)*4.*occ*dif*(.1+.9*sha);"
       "col=mate.xyz*lin;"
       "col=mix(bgcol,col,exp(-.0015*pow(tmat.x,1.)));"
       "vec4 worldHitPos=mviewproj*vec4(pos,1.);"
       "float zc=worldHitPos.z,wc=worldHitPos.w;"
       "depth=zc/wc;"
       "depth=(depth+1.)/2.;"
     "}"
   "col+=vec3(1.,.6,.2)*.4*pow(sun,4.);"
   "col=pow(clamp(col,0.,1.),vec3(.45));"
   "gl_FragDepth=depth;"
   "gl_FragColor=vec4(vec3(col),1.);"
 "}";

const char* const rm_vert =
 "varying vec3 cameraPosition,viewDirection;"
 "varying mat4 pmat,mview,mviewproj;"
 "void main()"
 "{"
   "gl_Position=gl_Vertex;"
   "vec4 v=gl_Vertex;"
   "v=gl_ProjectionMatrixInverse*v;"
   "v/=v.w;"
   "v=gl_ModelViewMatrixInverse*v;"
   "vec4 nearPlanePosition=v/v.w;"
   "mview=gl_ModelViewMatrix;"
   "mviewproj=gl_ModelViewProjectionMatrix;"
   "pmat=gl_ProjectionMatrix;"
   "cameraPosition=(gl_ModelViewMatrixInverse*vec4(0.,0.,0.,1.)).xyz;"
   "viewDirection=normalize(nearPlanePosition-cameraPosition).xyz;"
 "}";

const char* const rm_frag =
 "varying vec2 uv;"
 "uniform float time;"
 "uniform sampler2D iChannel0,iChannel1,iChannel2,mask;"
 "varying mat4 mview;"
 "varying float znear,zfar,nearPlane,farPlane;"
 "varying mat4 pmat;"
 "uniform vec3 sky1,sky2,lig,cube,objectPos;"
 "uniform float objectMix;"
 "varying vec3 cameraPosition;"
 "varying float nearPlanePosition;"
 "varying vec3 viewDirection;"
 "varying mat4 mviewproj;\n"
 "#define pi2 6.28318530718\n"
 "const float precis=.015;"
 "uniform vec2 g_resolution;struct hitInfo{int materialId;};"
 "float hash(float n)"
 "{"
   "return fract(sin(n)*43758.5);"
 "}"
 "float noise(in vec3 x)"
 "{"
   "vec3 p=floor(x),f=fract(x);"
   "float a=texture2D(iChannel0,x.xy/256.+p.z*120.712).x,b=texture2D(iChannel0,x.xy/256.+(p.z+1.)*120.712).x;"
   "return mix(a,b,f.z);"
 "}"
 "const mat3 m=mat3(0.,.8,.6,-.8,.36,-.48,-.6,-.48,.64);"
 "float noise(in vec2 x)"
 "{"
   "vec2 p=floor(x),f=fract(x),uv=p.xy+f.xy*f.xy*(3.-2.*f.xy);"
   "return-1.+2.*texture2D(iChannel0,(uv+.5)/256.,-100.).x;"
 "}"
 "vec3 texturize(sampler2D sa,vec3 p,vec3 n)"
 "{"
   "vec3 x=texture2D(sa,p.yz).xyz,y=texture2D(sa,p.zx).xyz,z=texture2D(sa,p.xy).xyz;"
   "return x*abs(n.x)+y*abs(n.y)+z*abs(n.z);"
 "}"
 "float fbm(vec3 p)"
 "{"
   "float f;"
   "f=.5*noise(p);"
   "p=m*p*2.02;"
   "f+=.25*noise(p);"
   "p=m*p*2.03;"
   "f+=.125*noise(p);"
   "p=m*p*2.01;"
   "f+=.0625*noise(p);"
   "return f;"
 "}"
 "mat3 rotz(in float a)"
 "{"
   "float ca=cos(a),sa=sin(a);"
   "return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.);"
 "}"
 "mat3 rotx(in float a)"
 "{"
   "float ca=cos(a),sa=sin(a);"
   "return mat3(1.,0.,0.,0.,ca,-sa,0.,sa,ca);"
 "}"
 "mat3 roty(in float a)"
 "{"
   "float ca=cos(a),sa=sin(a);"
   "return mat3(ca,0.,sa,0.,1.,0.,-sa,0.,ca);"
 "}"
 "vec2 opUnion(vec2 d1,vec2 d2)"
 "{"
   "return d1.x<d2.x?d1:d2;"
 "}"
 "float opSub(float d1,float d2)"
 "{"
   "return max(-d2,d1);"
 "}"
 "vec3 opRep(vec3 p,vec3 c)"
 "{"
   "return mod(p,c)-.5*c;"
 "}"
 "float length2(vec2 p)"
 "{"
   "return sqrt(p.x*p.x+p.y*p.y);"
 "}"
 "float length6(vec2 p)"
 "{"
   "p=p*p*p;"
   "p=p*p;"
   "return pow(p.x+p.y,1./6.);"
 "}"
 "float length8(vec2 p)"
 "{"
   "p=p*p;"
   "p=p*p;"
   "p=p*p;"
   "return pow(p.x+p.y,.125);"
 "}"
 "float sdTorus82(vec3 p,vec2 t)"
 "{"
   "vec2 q=vec2(length2(p.xz)-t.x,p.y);"
   "return length8(q)-t.y;"
 "}"
 "float sdCylinder(vec3 p,vec2 h)"
 "{"
   "return max(length(p.xz)-h.x,abs(p.y)-h.y);"
 "}"
 "float udRoundBox(vec3 pos,vec3 size,float r)"
 "{"
   "return length(max(abs(pos)-size,0.))-r;"
 "}"
 "float sdBox(vec3 p,vec3 b)"
 "{"
   "vec3 d=abs(p)-b;"
   "return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));"
 "}"
 "float sdCone(vec3 p,vec2 c)"
 "{"
   "float q=length(p.xz);"
   "return max(dot(c,vec2(q,p.y)),p.y);"
 "}"
 "float sdSphere(in vec3 p,in vec4 e)"
 "{"
   "vec3 di=p-e.xyz;"
   "return length(di)-e.w;"
 "}"
 "vec3 opTwist(vec3 p)"
 "{"
   "float c=cos(10.*p.y+10.),s=sin(10.*p.y+10.);"
   "mat2 m=mat2(c,-s,s,c);"
   "return vec3(m*p.xz,p.y);"
 "}"
 "vec2 sdSegment(vec3 a,vec3 b,vec3 p)"
 "{"
   "vec3 pa=p-a,ba=b-a;"
   "float h=clamp(dot(pa,ba)/dot(ba,ba),0.,1.);"
   "return vec2(length(pa-ba*h),h);"
 "}"
 "float smin(float a,float b)"
 "{"
   "float k=.06,h=clamp(.5+.5*(b-a)/k,0.,1.);"
   "return mix(b,a,h)-k*h*(1.-h);"
 "}"
 "float smin(float a,float b,float k)"
 "{"
   "float h=clamp(.5+.5*(b-a)/k,0.,1.);"
   "return mix(b,a,h)-k*h*(1.-h);"
 "}"
 "vec2 smin(vec2 a,vec2 b)"
 "{"
   "float k=1.6,h=clamp(.5+.5*(b.x-a.x)/k,0.,1.);"
   "return mix(b,a,h)-k*h*(1.-h);"
 "}"
 "float sdCylinder6(vec3 p,vec2 h)"
 "{"
   "return max(length6(p.xz)-h.x,abs(p.y)-h.y);"
 "}"
 "float sdCapsule(vec3 p,vec3 a,vec3 b,float r)"
 "{"
   "vec3 pa=p-a,ba=b-a;"
   "float h=clamp(dot(pa,ba)/dot(ba,ba),0.,1.);"
   "return length(pa-ba*h)-r;"
 "}\n"
 "#define MAT_NONE 0.0\n"
 "#define MAT_DBF 1.0\n"
 "#define MAT_GROUND 2.0\n"
 "#define MAT_TREE 3.0\n"
 "#define MAT_SNOW 4.0\n"
 "#define MAT_HAT 5.0\n"
 "#define MAT_EYE 6.0\n"
 "#define MAT_BODY 7.0\n"
 "#define MAT_NOSE 8.0\n"
 "#define MAT_ARM 9.0\n"
 "#define MAT_D 10.0\n"
 "#define MAT_B 11.0\n"
 "#define MAT_F 12.0\n"
 "vec2 map(in vec3 p,in bool masked)"
 "{"
   "vec2 res=vec2(1000.,-1.);"
   "float h=0,dd=p.y-h;"
   "res=vec2(dd,0.);"
   "float dis=100000.;"
   "res.x=min(dis,res.x);"
   "res.y=MAT_SNOW;"
   "res.x=sdBox(p,vec3(10.));"
   "return res;"
 "}"
 "vec3 intersect(in vec3 ro,in vec3 rd,in bool masked)"
 "{"
   "float maxd=500.,dist=precis*1.5,t=0.,d=0.,m=1.;"
   "for(int steps=0;steps<150;steps++)"
     "{"
       "if(abs(dist)<precis||t>maxd)"
         "continue;"
       "t+=dist;"
       "vec2 res=map(ro+rd*t,masked);"
       "dist=res.x;"
       "d=res.y;"
       "m=res.y;"
     "}"
   "if(t>maxd)"
     "m=-1.;"
   "return vec3(t,d,m);"
 "}"
 "vec3 calcNormal(in vec3 pos,in float prec,in bool masked)"
 "{"
   "vec3 eps=vec3(prec,0.,0.);"
   "return normalize(vec3(map(pos+eps.xyy,masked).x-map(pos-eps.xyy,masked).x,map(pos+eps.yxy,masked).x-map(pos-eps.yxy,masked).x,map(pos+eps.yyx,masked).x-map(pos-eps.yyx,masked).x));"
 "}"
 "vec3 calcNormal(in vec3 pos,in bool masked)"
 "{"
   "vec3 eps=vec3(precis,0.,0.);"
   "return normalize(vec3(map(pos+eps.xyy,masked).x-map(pos-eps.xyy,masked).x,map(pos+eps.yxy,masked).x-map(pos-eps.yxy,masked).x,map(pos+eps.yyx,masked).x-map(pos-eps.yyx,masked).x));"
 "}"
 "float softshadow(in vec3 ro,in vec3 rd,in float k,in bool masked)"
 "{"
   "float res=1.,t=0.,h=1.;"
   "for(int i=0;i<60;i++)"
     "{"
       "h=map(ro+rd*t,masked).x;"
       "res=min(res,k*h/t);"
       "t+=clamp(h,.02,1.);"
     "}"
   "return clamp(res,0.,1.);"
 "}"
 "float calcOcc(in vec3 pos,in vec3 nor,in bool masked)"
 "{"
   "float totao=0.;"
   "for(int aoi=0;aoi<8;aoi++)"
     "{"
       "float hr=.1+1.5*pow(float(aoi)/8.,2.);"
       "vec3 aopos=pos+nor*hr;"
       "float dd=map(aopos,masked).x;"
       "totao+=max(0.,hr-3.*dd-.01);"
     "}"
   "return clamp(1.-.15*totao,0.,1.);"
 "}"
 "vec3 background(vec3 p,vec3 d)"
 "{"
   "vec3 color=mix(sky1,sky2,d.y*.5+.5);"
   "return color*(noise(d)+.3*pow(noise(d*4.),2.));"
 "}"
 "void shade(in vec3 pos,in vec3 nor,in vec3 rd,in float matID,out vec3 bnor,out vec4 mate,out vec2 mate2)"
 "{"
   "bnor=vec3(0.);"
   "mate=vec4(0.);"
   "mate2=vec2(0.);"
   "vec3 snowTint=vec3(1.,1.,1.);"
   "if(matID==MAT_D)"
     "{"
       "snowTint=vec3(1.,1.,0.);"
     "}"
   "else"
     " if(matID==MAT_B)"
       "{"
         "snowTint=vec3(0.,1.,0.);"
       "}"
     "else"
       " if(matID==MAT_F)"
         "{"
           "snowTint=vec3(1.,0.,0.);"
         "}"
   "if(matID==MAT_HAT)"
     "{"
       "mate.xyz=vec3(.2,.3,.2);"
       "float iss=smoothstep(.2,.5,nor.y);"
       "vec3 snowColor=vec3(.65,.8,.8),cnor=normalize(-1.+2.*texture2D(iChannel0,.65*pos.xz).xyz);"
       "cnor.y=abs(cnor.y);"
       "float spe=max(0.,pow(clamp(dot(lig,reflect(rd,cnor)),0.,1.),16.));"
       "mate2.y=spe*iss;"
       "mate.xyz=mix(mate.xyz,snowColor,iss);"
     "}"
   "else"
     " if(matID==MAT_NOSE)"
       "{"
         "mate.xyz=vec3(.2,.175,.2);"
         "float iss=smoothstep(.2,.9,nor.y);"
         "iss=mix(iss,.2,.75*smoothstep(.9,1.,texturize(iChannel1,.1*pos,nor).x));"
         "vec3 snowColor=vec3(.65,.8,.8),cnor=normalize(-1.+2.*texture2D(iChannel0,.65*pos.xz).xyz);"
         "cnor.y=abs(cnor.y);"
         "float spe=max(0.,pow(clamp(dot(lig,reflect(rd,cnor)),0.,1.),16.));"
         "mate.y=spe*iss;"
         "mate.xyz=mix(mate.xyz,snowColor,iss);"
       "}"
     "else"
       " if(matID==MAT_EYE)"
         "{"
           "mate.xyz=vec3(.1,.1,.1);"
           "float iss=smoothstep(.2,.9,nor.y);"
           "vec3 snowColor=vec3(.65,.8,.8),cnor=normalize(-1.+2.*texture2D(iChannel0,.65*pos.xz).xyz);"
           "cnor.y=abs(cnor.y);"
           "float spe=max(0.,pow(clamp(dot(lig,reflect(rd,cnor)),0.,1.),16.));"
           "mate.y=spe*iss;"
           "mate.xyz=mix(mate.xyz,snowColor,iss*.5);"
         "}"
       "else"
         " if(matID==MAT_ARM)"
           "{"
             "mate.xyz=vec3(.4,.25,.2);"
             "float iss=smoothstep(.2,.5,nor.y);"
             "vec3 snowColor=vec3(.65,.8,.8),cnor=normalize(-1.+2.*texture2D(iChannel0,.65*pos.xz).xyz);"
             "cnor.y=abs(cnor.y);"
             "float spe=max(0.,pow(clamp(dot(lig,reflect(rd,cnor)),0.,1.),16.));"
             "mate.y=spe*iss;"
             "mate.xyz=mix(mate.xyz,snowColor,iss*.5);"
           "}"
         "else"
           "{"
             "mate.xyz=vec3(.1,.1,.1);"
             "float iss=smoothstep(.2,.5,nor.y);"
             "mate.xyz=vec3(.8,.8,.8)*snowTint;"
             "vec3 cnor=normalize(-1.+2.*texture2D(iChannel0,.65*pos.xz).xyz);"
             "cnor.y=abs(cnor.y);"
             "float spe=max(0.,pow(clamp(dot(lig,reflect(rd,cnor)),0.,1.),16.));"
             "mate.xyz=spe*iss;"
             "mate.xyz=mix(mate.xyz,vec3(.8),iss);"
             "mate.xyz+=sky1*cnor.y*1;"
             "mate.xyz+=sky2*cnor.y*1;"
           "}"
 "}"
 "float cloudShadow(in vec3 pos)"
 "{"
   "vec2 cuv=pos.xz+lig.xz*(100.-pos.y)/lig.y;"
   "float cc=.1+.9*smoothstep(.1,.35,texture2D(iChannel1,.0001*cuv+.1+.013*time).x);"
   "return cc;"
 "}"
 "vec3 snow(vec3 ro,vec3 rd)"
 "{"
   "return vec3(1.,1.,1.);"
 "}"
 "void main()"
 "{"
   "vec2 iMouse=vec2(0.,0.),fp=gl_FragCoord.xy/g_resolution.xy;"
   "bool masked=texture2D(mask,fp).x>.001;"
   "vec2 xy=-1.+2.*fp,s=xy*vec2(1.75,1.);"
   "float time=time*.15+2.*iMouse.x/g_resolution.x;"
   "vec3 ro=cameraPosition,rd=normalize(viewDirection);"
   "float ctime=time;"
   "vec3 tmat=intersect(ro,rd,masked),d=vec3(xy,1.),col=2.5*background(ro+tmat.x*rd,d)-rd.y*1.5;"
   "float sun=clamp(dot(rd,lig),0.,1.);"
   "vec3 bgcol=col;"
   "float depth=1.;"
   "if(tmat.z>-.5)"
     "{"
       "vec3 pos=ro+tmat.x*rd,nor=tmat.z==MAT_SNOW?calcNormal(pos,masked):calcNormal(pos,masked);"
       "vec4 mate=vec4(0.);"
       "vec2 mate2=vec2(0.);"
       "vec3 bnor=vec3(0.);"
       "shade(pos,nor,rd,tmat.z,bnor,mate,mate2);"
       "nor=normalize(nor+bnor);"
       "vec3 ref=reflect(rd,nor);"
       "float occ=calcOcc(pos,nor,masked)*clamp(.7+.3*nor.y,0.,1.),sky=.6+.4*nor.y,bou=clamp(-nor.y,0.,1.),dif=max(dot(nor,lig),0.),bac=max(.2+.8*dot(nor,normalize(vec3(-lig.x,0.,-lig.z))),0.),sha=0.;"
       "if(dif>.01)"
         "sha=softshadow(pos+.01*nor,lig,64.,masked);"
       "sha*=cloudShadow(pos);"
       "float fre=pow(clamp(1.+dot(nor,rd),0.,1.),3.);"
       "vec3 lin=vec3(0.);"
       "lin+=dif*vec3(1.7,1.15,.7)*pow(vec3(sha),vec3(1.,1.2,2.));"
       "lin+=sky*vec3(.25,.2,.25)*occ;"
       "lin+=1.2*bou*vec3(.15,.2,.2)*(.5+.5*occ);"
       "lin+=fre*vec3(1.,1.25,1.3)*occ*.5*(.5+.5*dif*sha);"
       "lin+=mate2.y*vec3(1.,.6,.5)*4.*occ*dif*(.1+.9*sha);"
       "col=mate.xyz*lin;"
       "col=mix(bgcol,col,exp(-.0015*pow(tmat.x,1.)));"
       "vec4 worldHitPos=mviewproj*vec4(pos,1.);"
       "float zc=worldHitPos.z,wc=worldHitPos.w;"
       "depth=zc/wc;"
       "depth=(depth+1.)/2.;"
     "}"
   "col+=vec3(1.,.6,.2)*.4*pow(sun,4.);"
   "col=pow(clamp(col,0.,1.),vec3(.45));"
   "gl_FragDepth=depth;"
   "gl_FragColor=vec4(vec3(col),1.);"
 "}";

const char* const particles_vert =
 "#version 330\n"
 "layout(location=0)in vec4 position;"
 "layout(location=1)in vec2 index;"
 "void main()"
 "{"
   "gl_Position=position;"
 "}";

const char* const particles_geom =
 "#version 330\n"
 "float rand(vec2 co)"
 "{"
   "return fract(sin(dot(co.xy,vec2(12.9898,78.233)))*43758.5);"
 "}"
 "float randGaussian(vec2 co)"
 "{"
   "float r1=rand(co+vec2(71.3,56.4)),r2=rand(co+vec2(32.9,28.5));"
   "return.03+sqrt(-2.*log(r1*.999+.001))*cos(6.28319*r2);"
 "}"
 "vec3 gauss3(vec2 p,float seed)"
 "{"
   "return vec3(randGaussian(p+vec2(19.412+seed*.981,11.183+seed*1.5677)),randGaussian(p+vec2(86.287+seed*4.6671,87.242+seed*8.6112)),randGaussian(p+vec2(37.563+seed*3.367,23.543+seed*5.729)));"
 "}\n"
 "#define pi2 6.28318530718\n"
 "layout(points)in;layout(triangle_strip,max_vertices=4)out;"
 "out vec2 quadCoord;"
 "out float quadSize;"
 "uniform mat4 modelViewMatrix,projectionMatrix;"
 "uniform float fTime;"
 "uniform vec3 eye,rot;"
 "mat3 rotz(in float a)"
 "{"
   "float ca=cos(a),sa=sin(a);"
   "return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.);"
 "}"
 "mat3 rotx(in float a)"
 "{"
   "float ca=cos(a),sa=sin(a);"
   "return mat3(1.,0.,0.,0.,ca,-sa,0.,sa,ca);"
 "}"
 "mat3 roty(in float a)"
 "{"
   "float ca=cos(a),sa=sin(a);"
   "return mat3(ca,0.,sa,0.,1.,0.,-sa,0.,ca);"
 "}\n"
 "#define DEG_PER_RAD 0.0174532925\n"
 "void main()"
 "{"
   "vec3 o=vec3(.05,0.,-.05)*.5;"
   "vec4 p=gl_in[0].gl_Position;"
   "vec3 r=vec3(rand(p.xy+vec2(23.098,47.863)),rand(p.xy+vec2(98.672,38.942)),rand(p.xy+vec2(86.573,24.182)));"
   "vec4 downVec=vec4(0.,1.,-.75,1.);"
   "downVec.xyz+=r*p.xyz;"
   "p.xyz=r;"
   "mat3 rotMat=rotx(pi2*(rot.x/360.));"
   "rotMat*=roty(pi2*(rot.y/360.));"
   "rotMat*=rotz(pi2*(rot.z/360.));"
   "p.xyz+=eye*.001;"
   "p.xyz-=(fTime+100.)*.05*downVec.xyz;"
   "p.xyz=mod(p.xyz,1.);"
   "p.xyz-=.5;"
   "p.xyz*=16.;"
   "p.xyz*=rotMat;"
   "p.w=1.;"
   "float size=.4;"
   "o*=size;"
   "if(size>.1)"
     "{"
       "quadSize=o.x*50.;"
       "gl_Position=projectionMatrix*(p+o.xzyy);"
       "quadCoord=vec2(1.,-1.);"
       "EmitVertex();"
       "gl_Position=projectionMatrix*(p+o.xxyy);"
       "quadCoord=vec2(1.,1.);"
       "EmitVertex();"
       "gl_Position=projectionMatrix*(p+o.zzyy);"
       "quadCoord=vec2(-1.,-1.);"
       "EmitVertex();"
       "gl_Position=projectionMatrix*(p+o.zxyy);"
       "quadCoord=vec2(-1.,1.);"
       "EmitVertex();"
     "}"
 "}";

const char* const particles_frag =
 "#version 330\n"
 "in vec2 quadCoord;"
 "in float quadSize;"
 "uniform vec2 viewportSize;"
 "uniform float aspectRatio;"
 "void main()"
 "{"
   "float hres=(viewportSize.y-viewportSize.y/aspectRatio)*.5;"
   "if(gl_FragCoord.y<hres||gl_FragCoord.y>viewportSize.y-hres)"
     "{"
       "discard;"
     "}"
   "float centerd=length(quadCoord),clampd=max(centerd-.2,0.),alphaFade=exp(-clampd*clampd*4.);"
   "if(alphaFade<.001)"
     "discard;"
   "gl_FragData[0]=vec4(1.);"
   "gl_FragData[0]=vec4(vec3(1.),alphaFade*2.*quadSize);"
 "}";

const char* const blit_vert =
 "void main()"
 "{"
   "gl_Position=gl_Vertex;"
 "}";

const char* const blit_frag =
 "uniform sampler2D t;"
 "void main()"
 "{"
   "vec2 p=gl_FragCoord.xy/vec2(800.,600.);"
   "gl_FragColor=vec4(texture2D(t,p).xyz,1.);"
 "}";

const char* const base_vert =
 "varying vec3 cameraPosition,viewDirection;"
 "varying mat4 pmat,mview,mviewproj;"
 "void main()"
 "{"
   "gl_Position=gl_Vertex;"
   "vec4 v=gl_Vertex;"
   "v=gl_ProjectionMatrixInverse*v;"
   "v/=v.w;"
   "v=gl_ModelViewMatrixInverse*v;"
   "vec4 nearPlanePosition=v/v.w;"
   "mview=gl_ModelViewMatrix;"
   "mviewproj=gl_ModelViewProjectionMatrix;"
   "pmat=gl_ProjectionMatrix;"
   "cameraPosition=(gl_ModelViewMatrixInverse*vec4(0.,0.,0.,1.)).xyz;"
   "viewDirection=normalize(nearPlanePosition-cameraPosition).xyz;"
 "}";

const char* const base_frag =
 "varying vec2 uv;"
 "uniform float time;"
 "uniform vec4 textBounds;"
 "uniform vec2 pixels[512];"
 "uniform int numPix;"
 "uniform sampler2D iChannel0,iChannel1,iChannel2,mask;"
 "varying mat4 mview;"
 "varying float znear,zfar,nearPlane,farPlane;"
 "varying mat4 pmat;"
 "uniform vec3 sky1,sky2,lig,cube,objectPos;"
 "uniform float objectMix;"
 "varying vec3 cameraPosition;"
 "varying float nearPlanePosition;"
 "varying vec3 viewDirection;"
 "varying mat4 mviewproj;\n"
 "#define pi2 6.28318530718\n"
 "const float precis=.015;"
 "uniform vec2 g_resolution;"
 "uniform int numChars;"
 "uniform mat3 chars[1];"
 "uniform vec2 charPos[1];struct hitInfo{int materialId;};"
 "float hash(float n)"
 "{"
   "return fract(sin(n)*43758.5);"
 "}"
 "float noise(in vec3 x)"
 "{"
   "vec3 p=floor(x),f=fract(x);"
   "float a=texture2D(iChannel0,x.xy/256.+p.z*120.712).x,b=texture2D(iChannel0,x.xy/256.+(p.z+1.)*120.712).x;"
   "return mix(a,b,f.z);"
 "}"
 "const mat3 m=mat3(0.,.8,.6,-.8,.36,-.48,-.6,-.48,.64);"
 "float noise(in vec2 x)"
 "{"
   "vec2 p=floor(x),f=fract(x),uv=p.xy+f.xy*f.xy*(3.-2.*f.xy);"
   "return-1.+2.*texture2D(iChannel0,(uv+.5)/256.,-100.).x;"
 "}"
 "vec3 texturize(sampler2D sa,vec3 p,vec3 n)"
 "{"
   "vec3 x=texture2D(sa,p.yz).xyz,y=texture2D(sa,p.zx).xyz,z=texture2D(sa,p.xy).xyz;"
   "return x*abs(n.x)+y*abs(n.y)+z*abs(n.z);"
 "}"
 "float fbm(vec3 p)"
 "{"
   "float f;"
   "f=.5*noise(p);"
   "p=m*p*2.02;"
   "f+=.25*noise(p);"
   "p=m*p*2.03;"
   "f+=.125*noise(p);"
   "p=m*p*2.01;"
   "f+=.0625*noise(p);"
   "return f;"
 "}"
 "mat3 rotz(in float a)"
 "{"
   "float ca=cos(a),sa=sin(a);"
   "return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.);"
 "}"
 "mat3 rotx(in float a)"
 "{"
   "float ca=cos(a),sa=sin(a);"
   "return mat3(1.,0.,0.,0.,ca,-sa,0.,sa,ca);"
 "}"
 "mat3 roty(in float a)"
 "{"
   "float ca=cos(a),sa=sin(a);"
   "return mat3(ca,0.,sa,0.,1.,0.,-sa,0.,ca);"
 "}"
 "vec2 opUnion(vec2 d1,vec2 d2)"
 "{"
   "return d1.x<d2.x?d1:d2;"
 "}"
 "float opSub(float d1,float d2)"
 "{"
   "return max(-d2,d1);"
 "}"
 "vec3 opRep(vec3 p,vec3 c)"
 "{"
   "return mod(p,c)-.5*c;"
 "}"
 "float length2(vec2 p)"
 "{"
   "return sqrt(p.x*p.x+p.y*p.y);"
 "}"
 "float length6(vec2 p)"
 "{"
   "p=p*p*p;"
   "p=p*p;"
   "return pow(p.x+p.y,1./6.);"
 "}"
 "float length8(vec2 p)"
 "{"
   "p=p*p;"
   "p=p*p;"
   "p=p*p;"
   "return pow(p.x+p.y,.125);"
 "}"
 "float sdTorus82(vec3 p,vec2 t)"
 "{"
   "vec2 q=vec2(length2(p.xz)-t.x,p.y);"
   "return length8(q)-t.y;"
 "}"
 "float sdCylinder(vec3 p,vec2 h)"
 "{"
   "return max(length(p.xz)-h.x,abs(p.y)-h.y);"
 "}"
 "float udRoundBox(vec3 pos,vec3 size,float r)"
 "{"
   "return length(max(abs(pos)-size,0.))-r;"
 "}"
 "float sdBox(vec3 p,vec3 b)"
 "{"
   "vec3 d=abs(p)-b;"
   "return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));"
 "}"
 "float sdCone(vec3 p,vec2 c)"
 "{"
   "float q=length(p.xz);"
   "return max(dot(c,vec2(q,p.y)),p.y);"
 "}"
 "float sdSphere(in vec3 p,in vec4 e)"
 "{"
   "vec3 di=p-e.xyz;"
   "return length(di)-e.w;"
 "}"
 "vec3 opTwist(vec3 p)"
 "{"
   "float c=cos(10.*p.y+10.),s=sin(10.*p.y+10.);"
   "mat2 m=mat2(c,-s,s,c);"
   "return vec3(m*p.xz,p.y);"
 "}"
 "vec2 sdSegment(vec3 a,vec3 b,vec3 p)"
 "{"
   "vec3 pa=p-a,ba=b-a;"
   "float h=clamp(dot(pa,ba)/dot(ba,ba),0.,1.);"
   "return vec2(length(pa-ba*h),h);"
 "}"
 "float smin(float a,float b)"
 "{"
   "float k=.06,h=clamp(.5+.5*(b-a)/k,0.,1.);"
   "return mix(b,a,h)-k*h*(1.-h);"
 "}"
 "float smin(float a,float b,float k)"
 "{"
   "float h=clamp(.5+.5*(b-a)/k,0.,1.);"
   "return mix(b,a,h)-k*h*(1.-h);"
 "}"
 "vec2 smin(vec2 a,vec2 b)"
 "{"
   "float k=1.6,h=clamp(.5+.5*(b.x-a.x)/k,0.,1.);"
   "return mix(b,a,h)-k*h*(1.-h);"
 "}"
 "float sdCylinder6(vec3 p,vec2 h)"
 "{"
   "return max(length6(p.xz)-h.x,abs(p.y)-h.y);"
 "}"
 "float sdCapsule(vec3 p,vec3 a,vec3 b,float r)"
 "{"
   "vec3 pa=p-a,ba=b-a;"
   "float h=clamp(dot(pa,ba)/dot(ba,ba),0.,1.);"
   "return length(pa-ba*h)-r;"
 "}\n"
 "#define MAT_NONE 0.0\n"
 "#define MAT_DBF 1.0\n"
 "#define MAT_GROUND 2.0\n"
 "#define MAT_TREE 3.0\n"
 "#define MAT_SNOW 4.0\n"
 "#define MAT_HAT 5.0\n"
 "#define MAT_EYE 6.0\n"
 "#define MAT_BODY 7.0\n"
 "#define MAT_NOSE 8.0\n"
 "#define MAT_ARM 9.0\n"
 "#define MAT_D 10.0\n"
 "#define MAT_B 11.0\n"
 "#define MAT_F 12.0\n"
 "vec2 map(in vec3 p,in bool masked)"
 "{"
   "vec2 res=vec2(1000.,-1.);"
   "float h=0,dd=p.y-h;"
   "res=vec2(dd,0.);"
   "float dis=100000.;"
   "res.x=min(dis,res.x);"
   "res.y=MAT_SNOW;"
   "res.x=dis;"
   "if(masked)"
     "{"
       "for(int i=0;i<numPix;i++)"
         "{"
           "vec3 p2=p+vec3(-pixels[i].x*20.,-pixels[i].y*20.,0.);"
           "float dist=sdBox(p2,vec3(10.));"
           "res.x=min(res.x,dist);"
         "}"
     "}"
   "return res;"
 "}"
 "vec3 intersect(in vec3 ro,in vec3 rd,in bool masked)"
 "{"
   "float maxd=500.,dist=precis*1.5,t=0.,d=0.,m=1.;"
   "for(int steps=0;steps<150;steps++)"
     "{"
       "if(abs(dist)<precis||t>maxd)"
         "continue;"
       "t+=dist;"
       "vec2 res=map(ro+rd*t,masked);"
       "dist=res.x;"
       "d=res.y;"
       "m=res.y;"
     "}"
   "if(t>maxd)"
     "m=-1.;"
   "return vec3(t,d,m);"
 "}"
 "vec3 calcNormal(in vec3 pos,in float prec,in bool masked)"
 "{"
   "vec3 eps=vec3(prec,0.,0.);"
   "return normalize(vec3(map(pos+eps.xyy,masked).x-map(pos-eps.xyy,masked).x,map(pos+eps.yxy,masked).x-map(pos-eps.yxy,masked).x,map(pos+eps.yyx,masked).x-map(pos-eps.yyx,masked).x));"
 "}"
 "vec3 calcNormal(in vec3 pos,in bool masked)"
 "{"
   "vec3 eps=vec3(precis,0.,0.);"
   "return normalize(vec3(map(pos+eps.xyy,masked).x-map(pos-eps.xyy,masked).x,map(pos+eps.yxy,masked).x-map(pos-eps.yxy,masked).x,map(pos+eps.yyx,masked).x-map(pos-eps.yyx,masked).x));"
 "}"
 "float softshadow(in vec3 ro,in vec3 rd,in float k,in bool masked)"
 "{"
   "float res=1.,t=0.,h=1.;"
   "for(int i=0;i<60;i++)"
     "{"
       "h=map(ro+rd*t,masked).x;"
       "res=min(res,k*h/t);"
       "t+=clamp(h,.02,1.);"
     "}"
   "return clamp(res,0.,1.);"
 "}"
 "float calcOcc(in vec3 pos,in vec3 nor,in bool masked)"
 "{"
   "float totao=0.;"
   "for(int aoi=0;aoi<8;aoi++)"
     "{"
       "float hr=.1+1.5*pow(float(aoi)/8.,2.);"
       "vec3 aopos=pos+nor*hr;"
       "float dd=map(aopos,masked).x;"
       "totao+=max(0.,hr-3.*dd-.01);"
     "}"
   "return clamp(1.-.15*totao,0.,1.);"
 "}"
 "vec3 background(vec3 p,vec3 d)"
 "{"
   "vec3 color=mix(sky1,sky2,d.y*.5+.5);"
   "return color*(noise(d)+.3*pow(noise(d*4.),2.));"
 "}"
 "void shade(in vec3 pos,in vec3 nor,in vec3 rd,in float matID,out vec3 bnor,out vec4 mate,out vec2 mate2)"
 "{"
   "bnor=vec3(0.);"
   "mate=vec4(0.);"
   "mate2=vec2(0.);"
   "vec3 snowTint=vec3(1.,1.,1.);"
   "if(matID==MAT_D)"
     "{"
       "snowTint=vec3(1.,1.,0.);"
     "}"
   "else"
     " if(matID==MAT_B)"
       "{"
         "snowTint=vec3(0.,1.,0.);"
       "}"
     "else"
       " if(matID==MAT_F)"
         "{"
           "snowTint=vec3(1.,0.,0.);"
         "}"
   "if(matID==MAT_HAT)"
     "{"
       "mate.xyz=vec3(.2,.3,.2);"
       "float iss=smoothstep(.2,.5,nor.y);"
       "vec3 snowColor=vec3(.65,.8,.8),cnor=normalize(-1.+2.*texture2D(iChannel0,.65*pos.xz).xyz);"
       "cnor.y=abs(cnor.y);"
       "float spe=max(0.,pow(clamp(dot(lig,reflect(rd,cnor)),0.,1.),16.));"
       "mate2.y=spe*iss;"
       "mate.xyz=mix(mate.xyz,snowColor,iss);"
     "}"
   "else"
     " if(matID==MAT_NOSE)"
       "{"
         "mate.xyz=vec3(.2,.175,.2);"
         "float iss=smoothstep(.2,.9,nor.y);"
         "iss=mix(iss,.2,.75*smoothstep(.9,1.,texturize(iChannel1,.1*pos,nor).x));"
         "vec3 snowColor=vec3(.65,.8,.8),cnor=normalize(-1.+2.*texture2D(iChannel0,.65*pos.xz).xyz);"
         "cnor.y=abs(cnor.y);"
         "float spe=max(0.,pow(clamp(dot(lig,reflect(rd,cnor)),0.,1.),16.));"
         "mate.y=spe*iss;"
         "mate.xyz=mix(mate.xyz,snowColor,iss);"
       "}"
     "else"
       " if(matID==MAT_EYE)"
         "{"
           "mate.xyz=vec3(.1,.1,.1);"
           "float iss=smoothstep(.2,.9,nor.y);"
           "vec3 snowColor=vec3(.65,.8,.8),cnor=normalize(-1.+2.*texture2D(iChannel0,.65*pos.xz).xyz);"
           "cnor.y=abs(cnor.y);"
           "float spe=max(0.,pow(clamp(dot(lig,reflect(rd,cnor)),0.,1.),16.));"
           "mate.y=spe*iss;"
           "mate.xyz=mix(mate.xyz,snowColor,iss*.5);"
         "}"
       "else"
         " if(matID==MAT_ARM)"
           "{"
             "mate.xyz=vec3(.4,.25,.2);"
             "float iss=smoothstep(.2,.5,nor.y);"
             "vec3 snowColor=vec3(.65,.8,.8),cnor=normalize(-1.+2.*texture2D(iChannel0,.65*pos.xz).xyz);"
             "cnor.y=abs(cnor.y);"
             "float spe=max(0.,pow(clamp(dot(lig,reflect(rd,cnor)),0.,1.),16.));"
             "mate.y=spe*iss;"
             "mate.xyz=mix(mate.xyz,snowColor,iss*.5);"
           "}"
         "else"
           "{"
             "mate.xyz=vec3(.1,.1,.1);"
             "float iss=smoothstep(.2,.5,nor.y);"
             "mate.xyz=vec3(.8,.8,.8)*snowTint;"
             "vec3 cnor=normalize(-1.+2.*texture2D(iChannel0,.65*pos.xz).xyz);"
             "cnor.y=abs(cnor.y);"
             "float spe=max(0.,pow(clamp(dot(lig,reflect(rd,cnor)),0.,1.),16.));"
             "mate.xyz=spe*iss;"
             "mate.xyz=mix(mate.xyz,vec3(.8),iss);"
             "mate.xyz+=sky1*cnor.y*1;"
             "mate.xyz+=sky2*cnor.y*1;"
           "}"
 "}"
 "float cloudShadow(in vec3 pos)"
 "{"
   "vec2 cuv=pos.xz+lig.xz*(100.-pos.y)/lig.y;"
   "float cc=.1+.9*smoothstep(.1,.35,texture2D(iChannel1,.0001*cuv+.1+.013*time).x);"
   "return cc;"
 "}"
 "vec3 snow(vec3 ro,vec3 rd)"
 "{"
   "return vec3(1.,1.,1.);"
 "}"
 "void main()"
 "{"
   "vec2 iMouse=vec2(0.,0.),fp=gl_FragCoord.xy/g_resolution.xy;"
   "bool masked=texture2D(mask,fp).x>.001;"
   "vec2 xy=-1.+2.*fp,s=xy*vec2(1.75,1.);"
   "float time=time*.15+2.*iMouse.x/g_resolution.x;"
   "vec3 ro=cameraPosition,rd=normalize(viewDirection);"
   "float ctime=time;"
   "vec3 tmat=intersect(ro,rd,masked),d=vec3(xy,1.),col=2.5*vec3(.18,.1,.1)-rd.y*.5;"
   "float sun=clamp(dot(rd,lig),0.,1.);"
   "vec3 bgcol=col;"
   "float depth=1.;"
   "if(tmat.z>-.5)"
     "{"
       "vec3 pos=ro+tmat.x*rd,nor=tmat.z==MAT_SNOW?calcNormal(pos,masked):calcNormal(pos,masked);"
       "vec4 mate=vec4(0.);"
       "vec2 mate2=vec2(0.);"
       "vec3 bnor=vec3(0.);"
       "shade(pos,nor,rd,tmat.z,bnor,mate,mate2);"
       "nor=normalize(nor+bnor);"
       "vec3 ref=reflect(rd,nor);"
       "float occ=calcOcc(pos,nor,masked)*clamp(.7+.3*nor.y,0.,1.),sky=.6+.4*nor.y,bou=clamp(-nor.y,0.,1.),dif=max(dot(nor,lig),0.),bac=max(.2+.8*dot(nor,normalize(vec3(-lig.x,0.,-lig.z))),0.),sha=0.;"
       "if(dif>.01)"
         "sha=softshadow(pos+.01*nor,lig,64.,masked);"
       "sha*=cloudShadow(pos);"
       "float fre=pow(clamp(1.+dot(nor,rd),0.,1.),3.);"
       "vec3 lin=vec3(0.);"
       "lin+=dif*vec3(1.7,1.15,.7)*pow(vec3(sha),vec3(1.,1.2,2.));"
       "lin+=sky*vec3(.25,.2,.25)*occ;"
       "lin+=1.2*bou*vec3(.15,.2,.2)*(.5+.5*occ);"
       "lin+=fre*vec3(1.,1.25,1.3)*occ*.5*(.5+.5*dif*sha);"
       "lin+=mate2.y*vec3(1.,.6,.5)*4.*occ*dif*(.1+.9*sha);"
       "col=mate.xyz*lin;"
       "col=mix(bgcol,col,exp(-.0015*pow(tmat.x,1.)));"
       "vec4 worldHitPos=mviewproj*vec4(pos,1.);"
       "float zc=worldHitPos.z,wc=worldHitPos.w;"
       "depth=zc/wc;"
       "depth=(depth+1.)/2.;"
     "}"
   "col+=vec3(1.,.6,.2)*.4*pow(sun,4.);"
   "col+=texture2D(iChannel1,fp);"
   "if(masked)"
     "{"
       "col+=vec3(1.,0.,0.)*.25;"
     "}"
   "gl_FragDepth=depth;"
   "gl_FragColor=vec4(vec3(col),1.);"
 "}";

#endif // SHADER_CODE_INTRO_H_
