/* File generated with Shader Minifier 1.1.3
 * http://www.ctrl-alt-test.fr
 */
#ifndef SHADER_CODE_H_
# define SHADER_CODE_H_

const char *ssao_vs_glsl =
 "varying vec2 vUv;"
 "void main()"
 "{"
   "vUv=gl_MultiTexCoord0.xy,gl_Position=gl_ProjectionMatrix*gl_ModelViewMatrix*gl_Vertex;"
 "}";

const char *ssao_fs_glsl =
 "uniform float cameraNear,cameraFar,fogNear,fogFar;"
 "uniform bool fogEnabled,onlyAO;"
 "uniform vec2 size;"
 "uniform float aoClamp,lumInfluence;"
 "uniform sampler2D tDiffuse,tDepth;"
 "varying vec2 vUv;\n"
 "#define DL 2.399963229728653\n"
 "#define EULER 2.718281828459045\n"
 "float v=size.x,f=size.y,t=cameraFar+cameraNear,c=cameraFar-cameraNear,i=2.*cameraNear;"
 "const int s=6;"
 "const float e=10.;"
 "const bool m=true;"
 "const float r=.0005,d=.4,y=.3;"
 "const vec3 x=vec3(1.,.7,.5);"
 "float n(const in vec4 v)"
 "{"
   "const vec4 f=vec4(5.96046e-08,1./65536.,1./256.,1.);"
   "float i=dot(v,f);"
   "return i;"
 "}"
 "vec2 D(const vec2 i)"
 "{"
   "vec2 c;"
   "if(m)"
     "{"
       "float t=dot(i,vec2(12.9898,78.233)),y=dot(i,vec2(12.9898,78.233)*2.);"
       "c=clamp(fract(43758.5*sin(vec2(t,y))),0.,1.);"
     "}"
   "else"
     "{"
       "float t=fract(1.-i.x*(v/2.)),e=fract(i.y*(f/2.));"
       "c=vec2(.25,.75)*vec2(t)+vec2(.75,.25)*e;"
     "}"
   "return(c*2.-1.)*r;"
 "}"
 "float D()"
 "{"
   "float v=n(texture2D(tDepth,vUv)),f=-cameraFar*cameraNear/(v*c-cameraFar);"
   "return smoothstep(fogNear,fogFar,f);"
 "}"
 "float p(const in vec2 v)"
 "{"
   "return i/(t-n(texture2D(tDepth,v))*c);"
 "}"
 "float D(const in float v,const in float i,inout int f)"
 "{"
   "float t=2.,c=(v-i)*100.;"
   "if(c<y)"
     "t=d;"
   "else"
     " f=1;"
   "float x=c-y,e=pow(EULER,-2.*x*x/(t*t));"
   "return e;"
 "}"
 "float n(float v,float i,float f)"
 "{"
   "float c=e-v*e;"
   "vec2 r=vec2(i,f),t=vUv+c*r,y=vUv-c*r;"
   "float s=0.,x=0.;"
   "int m=0;"
   "s=D(v,p(t),m);"
   "if(m>0)"
     "x=D(p(y),v,m),s+=(1.-s)*x;"
   "return s;"
 "}"
 "void main()"
 "{"
   "vec2 i=D(vUv);"
   "float t=p(vUv),c=clamp(t,aoClamp,1.),r=1./v/c+i.x*(1.-i.x),y=1./f/c+i.y*(1.-i.y),e=0.,m=0.,d=0.,a=1./float(s),u=1.-a/2.,g=0.;"
   "for(int b=0;b<=s;b++)"
     "{"
       "float l=sqrt(1.-u);"
       "e=cos(g)*l;"
       "m=sin(g)*l;"
       "d+=n(t,e*r,m*y);"
       "u=u-a;"
       "g=g+DL;"
     "}"
   "d/=float(s);"
   "d=1.-d;"
   "if(fogEnabled)"
     "d=mix(d,1.,D());"
   "vec3 b=texture2D(tDiffuse,vUv).xyz,l=texture2D(tDepth,vUv).xyz,o=vec3(.299,.587,.114);"
   "float E=dot(b.xyz,o);"
   "vec3 U=vec3(E),z=vec3(b*mix(vec3(d),vec3(1.),U*lumInfluence));"
   "if(onlyAO)"
     "z=x*vec3(mix(vec3(d),vec3(1.),U*lumInfluence));"
   "gl_FragColor=vec4(z,1.);"
 "}";

const char *spinner_vs_glsl =
 "#version 330\n"
 "uniform float fArmMult;"
 "layout(location=0)in vec4 position;layout(location=1)in vec2 index;out CubeData{vec2 index;float time;float scale;float xrot;float yrot;vec3 offset;}vertex;\n"
 "#define HPI 1.57079\n"
 "#define PI 3.141592\n"
 "#define PI2 6.283185\n"
 "float v(vec2 v)"
 "{"
   "return fract(sin(dot(v.xy,vec2(12.9898,78.233)))*43758.5);"
 "}"
 "float t(vec2 f)"
 "{"
   "float t=v(f+vec2(71.3,56.4)),c=v(f+vec2(32.9,28.5));"
   "return.03+sqrt(-2.*log(t*.999+.001))*cos(6.28319*c);"
 "}"
 "void main()"
 "{"
   "float v=PI2/fArmMult,f=256.;"
   "gl_Position=position;"
   "vertex.index=index;"
   "float i=t(position.xy),c=t(position.xy*i),y=t(position.xy*c),e=t(position.xy*y);"
   "vec4 s=vec4(i,c,y,e);"
   "vertex.time=s.x*50.+50.;"
   "vertex.scale=s.y*.2+.3;"
   "vertex.xrot=floor(s.z*2.+2.)*v;"
   "vertex.yrot=floor(s.w*2.+2.)*v;"
   "vertex.offset=s.xyz*.4;"
 "}";

const char *spinner_gs_glsl =
 "#version 330\n"
 "mat4 v(float v)"
 "{"
   "float f=cos(v),c=sin(v);"
   "return mat4(1,0,0,0,0,f,c,0,0,-c,f,0,0,0,0,1);"
 "}"
 "mat4 t(float v)"
 "{"
   "float f=cos(v),c=sin(v);"
   "return mat4(f,0,-c,0,0,1,0,0,c,0,f,0,0,0,0,1);"
 "}"
 "mat4 f(float v)"
 "{"
   "float f=cos(v),c=sin(v);"
   "return mat4(f,c,0,0,-c,f,0,0,0,0,1,0,0,0,0,1);"
 "}"
 "mat4 f(float v,float f,float i)"
 "{"
   "return mat4(v,0,0,0,0,f,0,0,0,0,i,0,0,0,0,1);"
 "}"
 "mat4 t(float v,float f,float i)"
 "{"
   "return mat4(1,0,0,0,0,1,0,0,0,0,1,0,v,f,i,1);"
 "}"
 "uniform mat4 projectionMatrix,viewMatrix,modelViewMatrix;"
 "uniform float fArmLength,fScaleRotX,fScaleRotY,fScaleRotZ,fArmBend,fSeed1,fSeed2;"
 "layout(points)in;layout(triangle_strip,max_vertices=24)out;in CubeData{vec2 index;float time;float scale;float xrot;float yrot;vec3 offset;}vertex[];"
 "uniform float fTime;"
 "float s(vec2 v)"
 "{"
   "return fract(sin(dot(v.xy,vec2(12.9898,78.233)))*43758.5);"
 "}"
 "float i(vec2 v)"
 "{"
   "float f=s(v+vec2(71.3,56.4)),c=s(v+vec2(32.9,28.5));"
   "return.03+sqrt(-2.*log(f*.999+.001))*cos(6.28319*c);"
 "}"
 "vec4 c[8];"
 "out vec3 viewspaceNormal;"
 "out vec4 viewspacePosition4;"
 "out vec3 viewspacePosition3;"
 "void f(int v,int f,int i,int t,vec4 s)"
 "{"
   "viewspaceNormal=normalize(s.xyz),viewspacePosition4=c[v],viewspacePosition3=c[v].xyz,gl_Position=projectionMatrix*c[v],EmitVertex(),viewspacePosition4=c[f],viewspacePosition3=c[f].xyz,gl_Position=projectionMatrix*c[f],EmitVertex(),viewspacePosition4=c[i],viewspacePosition3=c[i].xyz,gl_Position=projectionMatrix*c[i],EmitVertex(),viewspacePosition4=c[t],viewspacePosition3=c[t].xyz,gl_Position=projectionMatrix*c[t],EmitVertex(),EndPrimitive();"
 "}"
 "void n(mat4 v)"
 "{"
   "mat4 t=modelViewMatrix*v;"
   "c[0]=t*vec4(1,1,1,1);"
   "c[1]=t*vec4(-1,1,1,1);"
   "c[2]=t*vec4(-1,-1,1,1);"
   "c[3]=t*vec4(1,-1,1,1);"
   "c[4]=t*vec4(1,1,-1,1);"
   "c[5]=t*vec4(-1,1,-1,1);"
   "c[6]=t*vec4(-1,-1,-1,1);"
   "c[7]=t*vec4(1,-1,-1,1);"
   "f(0,1,3,2,t*vec4(0,0,1,0));"
   "f(5,4,6,7,t*vec4(0,0,-1,0));"
   "f(4,0,7,3,t*vec4(1,0,0,0));"
   "f(1,5,2,6,t*vec4(-1,0,0,0));"
   "f(1,0,5,4,t*vec4(1,0,0,0));"
   "f(3,2,7,6,t*vec4(-1,0,0,0));"
 "}"
 "void main()"
 "{"
   "float c=fTime*.4-vertex[0].time;"
   "if(c>=0.&&c<1.)"
     "{"
       "mat4 i;"
       "float r=1.-c,y=vertex[0].scale*r,e=c*.2;"
       "i=t(0,0,0);"
       "i*=t(sin(fTime*.3-e));"
       "i*=v(cos(fTime*.16-e));"
       "i*=v(vertex[0].xrot);"
       "i*=t(vertex[0].yrot);"
       "i*=t(c*fArmLength+vertex[0].offset[0],vertex[0].offset[1],vertex[0].offset[2]);"
       "i*=f(fScaleRotX);"
       "i*=f(fScaleRotY);"
       "i*=f(fScaleRotZ);"
       "i*=f(y,y,y);"
       "n(i);"
     "}"
 "}";

const char *spinner_fs_glsl =
 "#version 330\n"
 "in vec3 viewspaceNormal,viewspacePosition3;"
 "in vec4 viewspacePosition4;"
 "in vec2 texturePosition;"
 "in vec3 objectPosition3,worldspacePosition3;"
 "uniform mat4 viewMatrix,modelViewMatrix,modelViewProjectionMatrix,viewMatrixMatrix;"
 "uniform mat3 normalMatrix;"
 "in float meshDistance;"
 "vec4 v(vec4 v,vec4 t,vec4 f,float i,float c,float y,vec3 m,vec3 s,vec3 r,vec3 p)"
 "{"
   "vec4 e=v;"
   "vec3 d=normalize(p),x=normalize(r-m);"
   "float l=dot(d,x);"
   "if(l>0.)"
     "{"
       "e+=t*l*i;"
       "vec3 n=normalize(s-m),z=reflect(-x,d);"
       "float b=pow(max(dot(z,n),0.),y);"
       "e+=f*b*c;"
     "}"
   "return e;"
 "}"
 "uniform vec4 cColor;"
 "uniform vec3 vLightPos;"
 "void main()"
 "{"
   "vec4 f=v(vec4(cColor),vec4(1.),vec4(1.),.3,.3,8.,viewspacePosition3,vec3(0),(viewMatrix*vec4(vLightPos,1.)).xyz,viewspaceNormal);"
   "gl_FragData[0]=vec4(f);"
   "gl_FragData[1]=vec4(viewspacePosition3,1.);"
   "gl_FragData[2]=vec4(0.);"
   "gl_FragData[3]=vec4(0.);"
 "}";

#endif // SHADER_CODE_H_
